
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">sss/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">sss/cmd/upload/main.go (0.0%)</option>
				
				<option value="file2">sss/internal/admin/apikey.go (73.5%)</option>
				
				<option value="file3">sss/internal/admin/audit.go (74.1%)</option>
				
				<option value="file4">sss/internal/admin/batch.go (69.7%)</option>
				
				<option value="file5">sss/internal/admin/bucket.go (71.2%)</option>
				
				<option value="file6">sss/internal/admin/handler.go (100.0%)</option>
				
				<option value="file7">sss/internal/admin/migrate.go (88.4%)</option>
				
				<option value="file8">sss/internal/admin/object.go (72.3%)</option>
				
				<option value="file9">sss/internal/admin/preview.go (87.2%)</option>
				
				<option value="file10">sss/internal/admin/session.go (91.0%)</option>
				
				<option value="file11">sss/internal/admin/settings.go (81.8%)</option>
				
				<option value="file12">sss/internal/admin/setup.go (88.5%)</option>
				
				<option value="file13">sss/internal/admin/stats.go (76.1%)</option>
				
				<option value="file14">sss/internal/api/bucket.go (67.0%)</option>
				
				<option value="file15">sss/internal/api/embed_dev.go (100.0%)</option>
				
				<option value="file16">sss/internal/api/handlers.go (72.4%)</option>
				
				<option value="file17">sss/internal/api/multipart.go (70.4%)</option>
				
				<option value="file18">sss/internal/api/object.go (71.8%)</option>
				
				<option value="file19">sss/internal/api/static.go (27.8%)</option>
				
				<option value="file20">sss/internal/auth/presign.go (100.0%)</option>
				
				<option value="file21">sss/internal/auth/signature.go (91.9%)</option>
				
				<option value="file22">sss/internal/config/config.go (100.0%)</option>
				
				<option value="file23">sss/internal/storage/apikeys.go (86.6%)</option>
				
				<option value="file24">sss/internal/storage/audit.go (89.6%)</option>
				
				<option value="file25">sss/internal/storage/crypto.go (74.5%)</option>
				
				<option value="file26">sss/internal/storage/filestore.go (79.0%)</option>
				
				<option value="file27">sss/internal/storage/gc.go (83.0%)</option>
				
				<option value="file28">sss/internal/storage/integrity.go (92.1%)</option>
				
				<option value="file29">sss/internal/storage/metadata.go (81.9%)</option>
				
				<option value="file30">sss/internal/storage/migrate.go (55.1%)</option>
				
				<option value="file31">sss/internal/storage/settings.go (89.5%)</option>
				
				<option value="file32">sss/internal/storage/stats.go (84.2%)</option>
				
				<option value="file33">sss/internal/utils/ip.go (96.9%)</option>
				
				<option value="file34">sss/internal/utils/logger.go (100.0%)</option>
				
				<option value="file35">sss/internal/utils/response.go (100.0%)</option>
				
				<option value="file36">sss/internal/utils/util.go (57.1%)</option>
				
				<option value="file37">sss/tools/upload_test_files.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        "sss/internal/api"
        "sss/internal/auth"
        "sss/internal/config"
        "sss/internal/storage"
        "sss/internal/utils"
)

func main() <span class="cov0" title="0">{
        // 命令行参数（运行时不可修改的配置）
        host := flag.String("host", "0.0.0.0", "监听地址")
        port := flag.Int("port", 8080, "监听端口")
        dbPath := flag.String("db", "./data/metadata.db", "数据库路径")
        dataPath := flag.String("data", "./data/buckets", "数据存储路径")
        logLevel := flag.String("log", "info", "日志级别 (debug/info/warn/error)")
        flag.Parse()

        // 1. 创建默认配置并应用命令行参数
        cfg := config.NewDefault()
        cfg.Server.Host = *host
        cfg.Server.Port = *port
        cfg.Storage.DBPath = *dbPath
        cfg.Storage.DataPath = *dataPath
        cfg.Log.Level = *logLevel

        // 初始化日志
        utils.InitLogger(cfg.Log.Level)
        utils.Info("SSS Server starting", "version", config.Version)

        // 2. 确保数据目录存在
        if err := os.MkdirAll(filepath.Dir(cfg.Storage.DBPath), 0755); err != nil </span><span class="cov0" title="0">{
                utils.Error("创建数据目录失败", "error", err)
                os.Exit(1)
        }</span>

        // 3. 初始化元数据存储
        <span class="cov0" title="0">metadata, err := storage.NewMetadataStore(cfg.Storage.DBPath)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("初始化数据库失败", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer metadata.Close()

        // 4. 从数据库加载配置（如果已安装）
        config.LoadFromDB(metadata)

        // 5. 初始化文件存储（使用可能更新后的路径）
        filestore, err := storage.NewFileStore(config.Global.Storage.DataPath)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("初始化文件存储失败", "error", err)
                os.Exit(1)
        }</span>

        // 6. 初始化 API Key 缓存
        <span class="cov0" title="0">auth.InitAPIKeyCache(metadata)
        utils.Info("API Key 缓存已初始化")

        // 7. 创建服务器
        server := api.NewServer(metadata, filestore)

        // 8. 显示启动信息
        addr := fmt.Sprintf("%s:%d", config.Global.Server.Host, config.Global.Server.Port)

        if metadata.IsInstalled() </span><span class="cov0" title="0">{
                utils.Info("系统已安装", "admin", config.Global.Auth.AdminUsername)
                if config.Global.Auth.AccessKeyID != "" </span><span class="cov0" title="0">{
                        utils.Info("API Key 已配置", "id", config.Global.Auth.AccessKeyID)
                }</span>
        } else<span class="cov0" title="0"> {
                utils.Warn("系统尚未安装，请访问 Web 界面完成初始化")
        }</span>

        // 9. 启动 HTTP 服务（带超时设置）
        <span class="cov0" title="0">httpServer := &amp;http.Server{
                Addr:         addr,
                Handler:      server,
                ReadTimeout:  60 * time.Second,
                WriteTimeout: 60 * time.Second,
                IdleTimeout:  120 * time.Second,
        }

        // 启动服务器（非阻塞）
        go func() </span><span class="cov0" title="0">{
                utils.Info("服务器启动", "address", addr, "region", config.Global.Server.Region)
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        utils.Error("服务器异常", "error", err)
                        os.Exit(1)
                }</span>
        }()

        // 10. 等待终止信号
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        sig := &lt;-quit
        utils.Info("收到终止信号，正在关闭服务器...", "signal", sig.String())

        // 11. 优雅关闭（等待最多 30 秒处理完当前请求）
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                utils.Error("服务器关闭失败", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">utils.Info("服务器已安全关闭")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bytes"
        "context"
        "fmt"
        "log"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        cfg, err := config.LoadDefaultConfig(ctx,
                config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                        "source-access-key",
                        "source-secret-key",
                        "",
                )),
                config.WithRegion("us-east-1"),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to load SDK config: %v", err)
        }</span>

        <span class="cov0" title="0">client := s3.NewFromConfig(cfg, func(o *s3.Options) </span><span class="cov0" title="0">{
                o.BaseEndpoint = aws.String("http://localhost:9001")
                o.UsePathStyle = true
        }</span>)

        // 上传测试文件
        <span class="cov0" title="0">files := map[string]string{
                "test1.txt":        "Test file 1 content",
                "folder/test2.txt": "Test file 2 content",
                "folder/data.json": `{"name": "test", "value": 123}`,
        }

        for key, content := range files </span><span class="cov0" title="0">{
                _, err := client.PutObject(ctx, &amp;s3.PutObjectInput{
                        Bucket: aws.String("source-bucket"),
                        Key:    aws.String(key),
                        Body:   bytes.NewReader([]byte(content)),
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to upload %s: %v", key, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Uploaded: %s\n", key)
                }</span>
        }

        // 列出对象
        <span class="cov0" title="0">fmt.Println("\n=== Source bucket contents ===")
        result, err := client.ListObjectsV2(ctx, &amp;s3.ListObjectsV2Input{
                Bucket: aws.String("source-bucket"),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to list objects: %v", err)
        }</span>

        <span class="cov0" title="0">for _, obj := range result.Contents </span><span class="cov0" title="0">{
                fmt.Printf("  %s (%d bytes)\n", *obj.Key, *obj.Size)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package admin

import (
        "encoding/json"
        "net/http"
        "strings"
        "time"

        "sss/internal/auth"
        "sss/internal/storage"
        "sss/internal/utils"
)

// CreateAPIKeyRequest 创建 API Key 请求
type CreateAPIKeyRequest struct {
        Description string `json:"description"`
}

// APIKeyResponse API Key 响应
type APIKeyResponse struct {
        AccessKeyID     string                     `json:"access_key_id"`
        SecretAccessKey string                     `json:"secret_access_key,omitempty"`
        Description     string                     `json:"description"`
        CreatedAt       string                     `json:"created_at"`
        Enabled         bool                       `json:"enabled"`
        Permissions     []storage.APIKeyPermission `json:"permissions"`
}

// UpdateAPIKeyRequest 更新 API Key 请求
type UpdateAPIKeyRequest struct {
        Description *string `json:"description,omitempty"`
        Enabled     *bool   `json:"enabled,omitempty"`
}

// SetPermissionRequest 设置权限请求
type SetPermissionRequest struct {
        BucketName string `json:"bucket_name"`
        CanRead    bool   `json:"can_read"`
        CanWrite   bool   `json:"can_write"`
}

// DeletePermissionRequest 删除权限请求
type DeletePermissionRequest struct {
        BucketName string `json:"bucket_name"`
}

// handleAPIKeys 处理 API Keys 列表/创建
func (h *Handler) handleAPIKeys(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.listAPIKeys(w, r)</span>
        case http.MethodPost:<span class="cov8" title="1">
                h.createAPIKey(w, r)</span>
        default:<span class="cov8" title="1">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}

// listAPIKeys 列出所有 API Keys
func (h *Handler) listAPIKeys(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        keys, err := h.metadata.ListAPIKeys()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("list api keys failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">result := make([]APIKeyResponse, 0, len(keys))
        for _, key := range keys </span><span class="cov8" title="1">{
                perms, _ := h.metadata.GetAPIKeyPermissions(key.AccessKeyID)
                result = append(result, APIKeyResponse{
                        AccessKeyID: key.AccessKeyID,
                        Description: key.Description,
                        CreatedAt:   key.CreatedAt.Format(time.RFC3339),
                        Enabled:     key.Enabled,
                        Permissions: perms,
                })
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, result)</span>
}

// createAPIKey 创建 API Key
func (h *Handler) createAPIKey(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreateAPIKeyRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        <span class="cov8" title="1">key, err := h.metadata.CreateAPIKey(req.Description)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("create api key failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 刷新缓存
        <span class="cov8" title="1">auth.ReloadAPIKeyCache()

        // 记录审计日志
        h.Audit(r, storage.AuditActionAPIKeyCreate, "admin", key.AccessKeyID, true, map[string]string{
                "description": req.Description,
        })

        utils.WriteJSONResponse(w, APIKeyResponse{
                AccessKeyID:     key.AccessKeyID,
                SecretAccessKey: key.SecretAccessKey, // 只在创建时返回
                Description:     key.Description,
                CreatedAt:       key.CreatedAt.Format(time.RFC3339),
                Enabled:         key.Enabled,
                Permissions:     []storage.APIKeyPermission{},
        })</span>
}

// handleAPIKeyDetail 处理单个 API Key 操作
func (h *Handler) handleAPIKeyDetail(w http.ResponseWriter, r *http.Request, path string) <span class="cov8" title="1">{
        parts := strings.SplitN(path, "/", 2)
        accessKeyID := parts[0]

        // 检查 API Key 是否存在
        key, err := h.metadata.GetAPIKey(accessKeyID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get api key failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if key == nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "NotFound", "API Key not found", http.StatusNotFound)
                return
        }</span>

        // 路由到具体操作
        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                // /api/admin/apikeys/{id}
                switch r.Method </span>{
                case http.MethodGet:<span class="cov8" title="1">
                        h.getAPIKey(w, r, accessKeyID)</span>
                case http.MethodPut:<span class="cov8" title="1">
                        h.updateAPIKey(w, r, accessKeyID)</span>
                case http.MethodDelete:<span class="cov8" title="1">
                        h.deleteAPIKey(w, r, accessKeyID)</span>
                default:<span class="cov8" title="1">
                        utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
                }
        } else<span class="cov8" title="1"> {
                // /api/admin/apikeys/{id}/permissions 或 /reset-secret
                action := parts[1]
                switch action </span>{
                case "permissions":<span class="cov8" title="1">
                        switch r.Method </span>{
                        case http.MethodPost:<span class="cov8" title="1">
                                h.setAPIKeyPermission(w, r, accessKeyID)</span>
                        case http.MethodDelete:<span class="cov8" title="1">
                                h.deleteAPIKeyPermission(w, r, accessKeyID)</span>
                        default:<span class="cov8" title="1">
                                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
                        }
                case "reset-secret":<span class="cov8" title="1">
                        if r.Method == http.MethodPost </span><span class="cov8" title="1">{
                                h.resetAPIKeySecret(w, r, accessKeyID)
                        }</span> else<span class="cov8" title="1"> {
                                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                        }</span>
                default:<span class="cov8" title="1">
                        utils.WriteErrorResponse(w, "NotFound", "API endpoint not found", http.StatusNotFound)</span>
                }
        }
}

// getAPIKey 获取 API Key 详情
func (h *Handler) getAPIKey(w http.ResponseWriter, r *http.Request, accessKeyID string) <span class="cov8" title="1">{
        key, err := h.metadata.GetAPIKey(accessKeyID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get api key failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">perms, _ := h.metadata.GetAPIKeyPermissions(accessKeyID)

        utils.WriteJSONResponse(w, APIKeyResponse{
                AccessKeyID: key.AccessKeyID,
                Description: key.Description,
                CreatedAt:   key.CreatedAt.Format(time.RFC3339),
                Enabled:     key.Enabled,
                Permissions: perms,
        })</span>
}

// updateAPIKey 更新 API Key
func (h *Handler) updateAPIKey(w http.ResponseWriter, r *http.Request, accessKeyID string) <span class="cov8" title="1">{
        var req UpdateAPIKeyRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        <span class="cov8" title="1">if req.Description != nil </span><span class="cov8" title="1">{
                if err := h.metadata.UpdateAPIKeyDescription(accessKeyID, *req.Description); err != nil </span><span class="cov0" title="0">{
                        utils.Error("update api key description failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                        return
                }</span>
        }

        <span class="cov8" title="1">if req.Enabled != nil </span><span class="cov8" title="1">{
                if err := h.metadata.UpdateAPIKeyEnabled(accessKeyID, *req.Enabled); err != nil </span><span class="cov0" title="0">{
                        utils.Error("update api key enabled failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                        return
                }</span>
        }

        // 刷新缓存
        <span class="cov8" title="1">auth.ReloadAPIKeyCache()

        // 记录审计日志
        h.Audit(r, storage.AuditActionAPIKeyUpdate, "admin", accessKeyID, true, nil)

        h.getAPIKey(w, r, accessKeyID)</span>
}

// deleteAPIKey 删除 API Key
func (h *Handler) deleteAPIKey(w http.ResponseWriter, r *http.Request, accessKeyID string) <span class="cov8" title="1">{
        if err := h.metadata.DeleteAPIKey(accessKeyID); err != nil </span><span class="cov0" title="0">{
                utils.Error("delete api key failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 刷新缓存
        <span class="cov8" title="1">auth.ReloadAPIKeyCache()

        // 记录审计日志
        h.Audit(r, storage.AuditActionAPIKeyDelete, "admin", accessKeyID, true, nil)

        utils.WriteJSONResponse(w, map[string]bool{"success": true})</span>
}

// setAPIKeyPermission 设置 API Key 权限
func (h *Handler) setAPIKeyPermission(w http.ResponseWriter, r *http.Request, accessKeyID string) <span class="cov8" title="1">{
        var req SetPermissionRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        <span class="cov8" title="1">if req.BucketName == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "bucket_name is required", http.StatusBadRequest)
                return
        }</span>

        // 验证桶名（如果不是通配符）
        <span class="cov8" title="1">if req.BucketName != "*" </span><span class="cov8" title="1">{
                bucket, err := h.metadata.GetBucket(req.BucketName)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("check bucket failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                        return
                }</span>
                <span class="cov8" title="1">if bucket == nil </span><span class="cov8" title="1">{
                        utils.WriteErrorResponse(w, "InvalidParameter", "Bucket does not exist", http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov8" title="1">perm := &amp;storage.APIKeyPermission{
                AccessKeyID: accessKeyID,
                BucketName:  req.BucketName,
                CanRead:     req.CanRead,
                CanWrite:    req.CanWrite,
        }

        if err := h.metadata.SetAPIKeyPermission(perm); err != nil </span><span class="cov0" title="0">{
                utils.Error("set api key permission failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 刷新缓存
        <span class="cov8" title="1">auth.ReloadAPIKeyCache()

        // 记录审计日志
        h.Audit(r, storage.AuditActionAPIKeySetPerm, "admin", accessKeyID, true, map[string]interface{}{
                "bucket":    req.BucketName,
                "can_read":  req.CanRead,
                "can_write": req.CanWrite,
        })

        h.getAPIKey(w, r, accessKeyID)</span>
}

// deleteAPIKeyPermission 删除 API Key 权限
func (h *Handler) deleteAPIKeyPermission(w http.ResponseWriter, r *http.Request, accessKeyID string) <span class="cov8" title="1">{
        // 从 query 参数获取 bucket_name
        bucketName := r.URL.Query().Get("bucket_name")
        if bucketName == "" </span><span class="cov8" title="1">{
                // 尝试从 body 获取
                var req DeletePermissionRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err == nil </span><span class="cov8" title="1">{
                        bucketName = req.BucketName
                }</span>
        }

        <span class="cov8" title="1">if bucketName == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "bucket_name is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.metadata.DeleteAPIKeyPermission(accessKeyID, bucketName); err != nil </span><span class="cov0" title="0">{
                utils.Error("delete api key permission failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 刷新缓存
        <span class="cov8" title="1">auth.ReloadAPIKeyCache()

        // 记录审计日志
        h.Audit(r, storage.AuditActionAPIKeyDelPerm, "admin", accessKeyID, true, map[string]string{
                "bucket": bucketName,
        })

        h.getAPIKey(w, r, accessKeyID)</span>
}

// resetAPIKeySecret 重置 API Key 的 Secret Key
func (h *Handler) resetAPIKeySecret(w http.ResponseWriter, r *http.Request, accessKeyID string) <span class="cov8" title="1">{
        newSecret, err := h.metadata.ResetAPIKeySecret(accessKeyID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("reset api key secret failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 刷新缓存
        <span class="cov8" title="1">auth.ReloadAPIKeyCache()

        // 获取 API Key 详情
        key, err := h.metadata.GetAPIKey(accessKeyID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get api key failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">perms, _ := h.metadata.GetAPIKeyPermissions(accessKeyID)

        // 记录审计日志
        h.Audit(r, storage.AuditActionAPIKeyResetSecret, "admin", accessKeyID, true, nil)

        // 返回包含新 Secret Key 的响应（仅此次返回）
        utils.WriteJSONResponse(w, APIKeyResponse{
                AccessKeyID:     key.AccessKeyID,
                SecretAccessKey: newSecret,
                Description:     key.Description,
                CreatedAt:       key.CreatedAt.Format(time.RFC3339),
                Enabled:         key.Enabled,
                Permissions:     perms,
        })</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package admin

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "sss/internal/storage"
        "sss/internal/utils"
)

// AuditLogResponse 审计日志响应
type AuditLogResponse struct {
        Logs  []storage.AuditLog `json:"logs"`
        Total int                `json:"total"`
        Limit int                `json:"limit"`
        Page  int                `json:"page"`
}

// handleAuditLogs 处理审计日志查询
func (h *Handler) handleAuditLogs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">query := &amp;storage.AuditLogQuery{}

        // 解析查询参数
        if action := r.URL.Query().Get("action"); action != "" </span><span class="cov8" title="1">{
                query.Action = storage.AuditAction(action)
        }</span>
        <span class="cov8" title="1">if actor := r.URL.Query().Get("actor"); actor != "" </span><span class="cov0" title="0">{
                query.Actor = actor
        }</span>
        <span class="cov8" title="1">if ip := r.URL.Query().Get("ip"); ip != "" </span><span class="cov0" title="0">{
                query.IP = ip
        }</span>
        <span class="cov8" title="1">if resource := r.URL.Query().Get("resource"); resource != "" </span><span class="cov0" title="0">{
                query.Resource = resource
        }</span>
        <span class="cov8" title="1">if startTime := r.URL.Query().Get("start_time"); startTime != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, startTime); err == nil </span><span class="cov0" title="0">{
                        query.StartTime = &amp;t
                }</span>
        }
        <span class="cov8" title="1">if endTime := r.URL.Query().Get("end_time"); endTime != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC3339, endTime); err == nil </span><span class="cov0" title="0">{
                        query.EndTime = &amp;t
                }</span>
        }
        <span class="cov8" title="1">if success := r.URL.Query().Get("success"); success != "" </span><span class="cov8" title="1">{
                b := success == "true" || success == "1"
                query.Success = &amp;b
        }</span>

        // 分页参数
        <span class="cov8" title="1">page := 1
        if p := r.URL.Query().Get("page"); p != "" </span><span class="cov8" title="1">{
                if v, err := strconv.Atoi(p); err == nil &amp;&amp; v &gt; 0 </span><span class="cov8" title="1">{
                        page = v
                }</span>
        }
        <span class="cov8" title="1">query.Limit = 50
        if limit := r.URL.Query().Get("limit"); limit != "" </span><span class="cov8" title="1">{
                if v, err := strconv.Atoi(limit); err == nil &amp;&amp; v &gt; 0 &amp;&amp; v &lt;= 100 </span><span class="cov8" title="1">{
                        query.Limit = v
                }</span>
        }
        <span class="cov8" title="1">query.Offset = (page - 1) * query.Limit

        logs, total, err := h.metadata.QueryAuditLogs(query)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("查询审计日志失败", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, AuditLogResponse{
                Logs:  logs,
                Total: total,
                Limit: query.Limit,
                Page:  page,
        })</span>
}

// handleAuditStats 获取审计统计
func (h *Handler) handleAuditStats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">stats, err := h.metadata.GetAuditStats()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("获取审计统计失败", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, stats)</span>
}

// Audit 记录审计日志的辅助方法
func (h *Handler) Audit(r *http.Request, action storage.AuditAction, actor, resource string, success bool, detail interface{}) <span class="cov8" title="1">{
        var detailStr string
        if detail != nil </span><span class="cov8" title="1">{
                if str, ok := detail.(string); ok </span><span class="cov8" title="1">{
                        detailStr = str
                }</span> else<span class="cov8" title="1"> {
                        if bytes, err := json.Marshal(detail); err == nil </span><span class="cov8" title="1">{
                                detailStr = string(bytes)
                        }</span>
                }
        }

        <span class="cov8" title="1">log := &amp;storage.AuditLog{
                Timestamp: time.Now().UTC(),
                Action:    action,
                Actor:     actor,
                IP:        utils.GetClientIP(r),
                Resource:  resource,
                Detail:    detailStr,
                Success:   success,
                UserAgent: utils.GetUserAgent(r),
        }

        if err := h.metadata.WriteAuditLog(log); err != nil </span><span class="cov0" title="0">{
                utils.Error("写入审计日志失败", "error", err, "action", action)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package admin

import (
        "archive/zip"
        "io"
        "net/http"
        "path/filepath"
        "strings"

        "sss/internal/utils"
)

// BatchDeleteRequest 批量删除请求
type BatchDeleteRequest struct {
        Keys []string `json:"keys"` // 要删除的 key 列表
}

// BatchDeleteResult 批量删除结果
type BatchDeleteResult struct {
        DeletedCount int      `json:"deleted_count"` // 成功删除数量
        FailedCount  int      `json:"failed_count"`  // 失败数量
        FailedKeys   []string `json:"failed_keys"`   // 失败的 key 列表
}

// BatchDownloadRequest 批量下载请求
type BatchDownloadRequest struct {
        Keys []string `json:"keys"` // 要下载的 key 列表
}

// batchDeleteObjects 批量删除对象
func (h *Handler) batchDeleteObjects(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">var req BatchDeleteRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        <span class="cov8" title="1">if len(req.Keys) == 0 </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "keys is required", http.StatusBadRequest)
                return
        }</span>

        // 限制单次批量删除数量
        <span class="cov8" title="1">if len(req.Keys) &gt; 1000 </span><span class="cov0" title="0">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Maximum 1000 keys per request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">result := BatchDeleteResult{
                FailedKeys: make([]string, 0),
        }

        for _, key := range req.Keys </span><span class="cov8" title="1">{
                // 安全检查：防止路径遍历
                if strings.Contains(key, "..") </span><span class="cov8" title="1">{
                        result.FailedCount++
                        result.FailedKeys = append(result.FailedKeys, key)
                        continue</span>
                }

                // 检查对象是否存在
                <span class="cov8" title="1">obj, err := h.metadata.GetObject(bucketName, key)
                if err != nil || obj == nil </span><span class="cov0" title="0">{
                        result.FailedCount++
                        result.FailedKeys = append(result.FailedKeys, key)
                        continue</span>
                }

                // 删除文件
                <span class="cov8" title="1">if err := h.filestore.DeleteObject(obj.StoragePath); err != nil </span><span class="cov0" title="0">{
                        utils.Error("batch delete file failed", "key", key, "error", err)
                }</span>

                // 删除元数据
                <span class="cov8" title="1">if err := h.metadata.DeleteObject(bucketName, key); err != nil </span><span class="cov0" title="0">{
                        result.FailedCount++
                        result.FailedKeys = append(result.FailedKeys, key)
                        continue</span>
                }

                <span class="cov8" title="1">result.DeletedCount++</span>
        }

        <span class="cov8" title="1">utils.WriteJSONResponse(w, result)</span>
}

// batchDownloadObjects 批量下载对象（打包为 ZIP）
func (h *Handler) batchDownloadObjects(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">var req BatchDownloadRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        <span class="cov8" title="1">if len(req.Keys) == 0 </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "keys is required", http.StatusBadRequest)
                return
        }</span>

        // 限制单次批量下载数量
        <span class="cov8" title="1">if len(req.Keys) &gt; 100 </span><span class="cov0" title="0">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Maximum 100 keys per request", http.StatusBadRequest)
                return
        }</span>

        // 设置响应头
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/zip")
        w.Header().Set("Content-Disposition", "attachment; filename=\""+bucketName+"-batch.zip\"")

        // 创建 ZIP 写入器
        zipWriter := zip.NewWriter(w)
        defer zipWriter.Close()

        for _, key := range req.Keys </span><span class="cov8" title="1">{
                // 安全检查：防止路径遍历
                if strings.Contains(key, "..") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 获取对象元数据
                <span class="cov8" title="1">obj, err := h.metadata.GetObject(bucketName, key)
                if err != nil || obj == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 创建 ZIP 条目
                <span class="cov8" title="1">header := &amp;zip.FileHeader{
                        Name:     filepath.Base(key), // 使用文件名而非完整路径
                        Method:   zip.Deflate,
                        Modified: obj.LastModified,
                }

                // 如果有同名文件，使用完整路径
                if containsDuplicate(req.Keys, key) </span><span class="cov0" title="0">{
                        header.Name = key
                }</span>

                <span class="cov8" title="1">zipEntry, err := zipWriter.CreateHeader(header)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("create zip entry failed", "key", key, "error", err)
                        continue</span>
                }

                // 读取并写入文件内容
                <span class="cov8" title="1">reader, err := h.filestore.GetObject(obj.StoragePath)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("read file for zip failed", "key", key, "error", err)
                        continue</span>
                }

                <span class="cov8" title="1">_, err = io.Copy(zipEntry, reader)
                reader.Close()
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("write to zip failed", "key", key, "error", err)
                }</span>
        }
}

// containsDuplicate 检查是否有同名文件
func containsDuplicate(keys []string, currentKey string) bool <span class="cov8" title="1">{
        baseName := filepath.Base(currentKey)
        count := 0
        for _, k := range keys </span><span class="cov8" title="1">{
                if filepath.Base(k) == baseName </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count &gt; 1</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package admin

import (
        "net/http"
        "strings"
        "time"

        "sss/internal/storage"
        "sss/internal/utils"
)

// AdminBucketInfo 管理员 API 桶信息
type AdminBucketInfo struct {
        Name         string `json:"name"`
        CreationDate string `json:"creation_date"`
        IsPublic     bool   `json:"is_public"`
}

// CreateBucketRequest 创建桶请求
type CreateBucketRequest struct {
        Name string `json:"name"`
}

// SetBucketPublicRequest 设置桶公开状态请求
type SetBucketPublicRequest struct {
        IsPublic bool `json:"is_public"`
}

// handleAdminBucketsAPI 管理员桶列表/创建 API
func (h *Handler) handleAdminBucketsAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.adminListBuckets(w, r)</span>
        case http.MethodPost:<span class="cov8" title="1">
                h.adminCreateBucket(w, r)</span>
        default:<span class="cov8" title="1">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}

// adminListBuckets 列出所有桶
func (h *Handler) adminListBuckets(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        buckets, err := h.metadata.ListBuckets()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("list buckets failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">result := make([]AdminBucketInfo, 0, len(buckets))
        for _, b := range buckets </span><span class="cov8" title="1">{
                result = append(result, AdminBucketInfo{
                        Name:         b.Name,
                        CreationDate: b.CreationDate.Format(time.RFC3339),
                        IsPublic:     b.IsPublic,
                })
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, result)</span>
}

// adminCreateBucket 创建桶
func (h *Handler) adminCreateBucket(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreateBucketRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        <span class="cov8" title="1">if req.Name == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Bucket name is required", http.StatusBadRequest)
                return
        }</span>

        // 验证桶名
        <span class="cov8" title="1">if strings.Contains(req.Name, "..") || strings.ContainsAny(req.Name, "/\\") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidBucketName", "Invalid bucket name", http.StatusBadRequest)
                return
        }</span>

        // 检查桶是否已存在
        <span class="cov8" title="1">existing, err := h.metadata.GetBucket(req.Name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if existing != nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "BucketAlreadyExists", "Bucket already exists", http.StatusConflict)
                return
        }</span>

        // 创建桶
        <span class="cov8" title="1">if err := h.metadata.CreateBucket(req.Name); err != nil </span><span class="cov0" title="0">{
                utils.Error("create bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 创建存储目录
        <span class="cov8" title="1">if err := h.filestore.CreateBucket(req.Name); err != nil </span><span class="cov0" title="0">{
                utils.Error("create bucket dir failed", "error", err)
                // 回滚数据库
                h.metadata.DeleteBucket(req.Name)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 记录审计日志
        <span class="cov8" title="1">h.Audit(r, storage.AuditActionBucketCreate, "admin", req.Name, true, nil)

        utils.WriteJSONResponse(w, map[string]interface{}{
                "success": true,
                "name":    req.Name,
        })</span>
}

// handleAdminBucketOps 管理员桶操作（删除、设置公开状态等）
func (h *Handler) handleAdminBucketOps(w http.ResponseWriter, r *http.Request, path string) <span class="cov8" title="1">{
        parts := strings.SplitN(path, "/", 2)
        bucketName := parts[0]

        if bucketName == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Bucket name is required", http.StatusBadRequest)
                return
        }</span>

        // 检查桶是否存在
        <span class="cov8" title="1">bucket, err := h.metadata.GetBucket(bucketName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if bucket == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "")
                return
        }</span>

        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                // /api/admin/buckets/{name} - 桶操作
                switch r.Method </span>{
                case http.MethodGet:<span class="cov8" title="1">
                        // 获取桶详情
                        utils.WriteJSONResponse(w, AdminBucketInfo{
                                Name:         bucket.Name,
                                CreationDate: bucket.CreationDate.Format(time.RFC3339),
                                IsPublic:     bucket.IsPublic,
                        })</span>
                case http.MethodPut:<span class="cov8" title="1">
                        // 更新桶设置（公开状态）
                        var req struct {
                                IsPublic bool `json:"isPublic"`
                        }
                        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                                return
                        }</span>
                        <span class="cov8" title="1">if err := h.metadata.UpdateBucketPublic(bucketName, req.IsPublic); err != nil </span><span class="cov0" title="0">{
                                utils.Error("update bucket public failed", "error", err)
                                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                                return
                        }</span>
                        <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]interface{}{
                                "success":  true,
                                "isPublic": req.IsPublic,
                        })</span>
                case http.MethodDelete:<span class="cov8" title="1">
                        h.adminDeleteBucket(w, r, bucketName)</span>
                default:<span class="cov8" title="1">
                        utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
                }
        } else<span class="cov8" title="1"> {
                action := parts[1]
                switch action </span>{
                case "public":<span class="cov8" title="1">
                        h.adminSetBucketPublic(w, r, bucketName)</span>
                case "objects":<span class="cov0" title="0">
                        h.adminObjectsHandler(w, r, bucketName)</span>
                case "upload":<span class="cov0" title="0">
                        h.adminUploadObject(w, r, bucketName)</span>
                case "download":<span class="cov0" title="0">
                        h.adminDownloadObject(w, r, bucketName)</span>
                case "batch/delete":<span class="cov0" title="0">
                        h.batchDeleteObjects(w, r, bucketName)</span>
                case "batch/download":<span class="cov0" title="0">
                        h.batchDownloadObjects(w, r, bucketName)</span>
                case "preview":<span class="cov0" title="0">
                        h.previewObject(w, r, bucketName)</span>
                default:<span class="cov8" title="1">
                        utils.WriteErrorResponse(w, "NotFound", "API endpoint not found", http.StatusNotFound)</span>
                }
        }
}

// adminDeleteBucket 删除桶
func (h *Handler) adminDeleteBucket(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if err := h.metadata.DeleteBucket(bucketName); err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "not empty") </span><span class="cov8" title="1">{
                        utils.WriteErrorResponse(w, "BucketNotEmpty", "Bucket is not empty", http.StatusConflict)
                }</span> else<span class="cov0" title="0"> {
                        utils.Error("delete bucket failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // 删除存储目录
        <span class="cov8" title="1">h.filestore.DeleteBucket(bucketName)

        // 记录审计日志
        h.Audit(r, storage.AuditActionBucketDelete, "admin", bucketName, true, nil)

        utils.WriteJSONResponse(w, map[string]bool{"success": true})</span>
}

// adminSetBucketPublic 设置桶公开状态
func (h *Handler) adminSetBucketPublic(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                bucket, _ := h.metadata.GetBucket(bucketName)
                utils.WriteJSONResponse(w, map[string]bool{"is_public": bucket.IsPublic})</span>
        case http.MethodPut:<span class="cov8" title="1">
                var req SetBucketPublicRequest
                if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                        return
                }</span>
                <span class="cov8" title="1">if err := h.metadata.UpdateBucketPublic(bucketName, req.IsPublic); err != nil </span><span class="cov0" title="0">{
                        utils.Error("update bucket public failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                        return
                }</span>
                // 记录审计日志
                <span class="cov8" title="1">if req.IsPublic </span><span class="cov8" title="1">{
                        h.Audit(r, storage.AuditActionBucketSetPublic, "admin", bucketName, true, nil)
                }</span> else<span class="cov8" title="1"> {
                        h.Audit(r, storage.AuditActionBucketSetPrivate, "admin", bucketName, true, nil)
                }</span>
                <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]bool{"is_public": req.IsPublic})</span>
        default:<span class="cov8" title="1">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package admin

import (
        "net/http"
        "strings"

        "sss/internal/storage"
        "sss/internal/utils"
)

// Handler 管理后台处理器
type Handler struct {
        metadata  *storage.MetadataStore
        filestore *storage.FileStore
}

// NewHandler 创建管理后台处理器
func NewHandler(metadata *storage.MetadataStore, filestore *storage.FileStore) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                metadata:  metadata,
                filestore: filestore,
        }
}</span>

// ServeHTTP 处理管理后台请求
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := r.URL.Path

        // 安装相关 API（无需认证）
        if strings.HasPrefix(path, "/api/setup") </span><span class="cov8" title="1">{
                h.handleSetupAPI(w, r)
                return
        }</span>

        // 登录 API（无需认证）
        <span class="cov8" title="1">if path == "/api/admin/login" </span><span class="cov8" title="1">{
                h.handleAdminLogin(w, r)
                return
        }</span>

        // 其他 API 需要认证
        <span class="cov8" title="1">if !h.checkAdminAuth(r) </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "Unauthorized", "未授权访问", http.StatusUnauthorized)
                return
        }</span>

        // 路由分发
        <span class="cov8" title="1">h.route(w, r)</span>
}

// route 路由分发
func (h *Handler) route(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := strings.TrimPrefix(r.URL.Path, "/api/admin/")

        switch </span>{
        case path == "logout":<span class="cov8" title="1">
                h.handleAdminLogout(w, r)</span>
        case path == "apikeys":<span class="cov8" title="1">
                h.handleAPIKeys(w, r)</span>
        case strings.HasPrefix(path, "apikeys/"):<span class="cov8" title="1">
                h.handleAPIKeyDetail(w, r, strings.TrimPrefix(path, "apikeys/"))</span>
        case path == "buckets":<span class="cov8" title="1">
                h.handleAdminBucketsAPI(w, r)</span>
        case strings.HasPrefix(path, "buckets/"):<span class="cov8" title="1">
                h.handleAdminBucketOps(w, r, strings.TrimPrefix(path, "buckets/"))</span>
        case path == "stats/overview":<span class="cov8" title="1">
                h.handleStorageStats(w, r)</span>
        case path == "stats/recent":<span class="cov8" title="1">
                h.handleRecentObjects(w, r)</span>
        case path == "storage/gc":<span class="cov8" title="1">
                h.handleGC(w, r)</span>
        case path == "storage/integrity":<span class="cov8" title="1">
                h.handleIntegrity(w, r)</span>
        case path == "migrate":<span class="cov8" title="1">
                h.handleMigrateAPI(w, r)</span>
        case strings.HasPrefix(path, "migrate/"):<span class="cov8" title="1">
                h.handleMigrateJob(w, r, strings.TrimPrefix(path, "migrate/"))</span>
        case path == "audit":<span class="cov8" title="1">
                h.handleAuditLogs(w, r)</span>
        case path == "audit/stats":<span class="cov8" title="1">
                h.handleAuditStats(w, r)</span>
        case path == "settings":<span class="cov8" title="1">
                h.handleSettings(w, r)</span>
        case path == "settings/password":<span class="cov8" title="1">
                h.handleChangePassword(w, r)</span>
        default:<span class="cov8" title="1">
                utils.WriteErrorResponse(w, "NotFound", "API endpoint not found", http.StatusNotFound)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package admin

import (
        "net/http"
        "strings"

        "sss/internal/storage"
        "sss/internal/utils"
)

// MigrateRequest 迁移请求
type MigrateRequest struct {
        SourceEndpoint  string `json:"sourceEndpoint"`
        SourceAccessKey string `json:"sourceAccessKey"`
        SourceSecretKey string `json:"sourceSecretKey"`
        SourceBucket    string `json:"sourceBucket"`
        SourcePrefix    string `json:"sourcePrefix"`
        SourceRegion    string `json:"sourceRegion"`
        TargetBucket    string `json:"targetBucket"`
        TargetPrefix    string `json:"targetPrefix"`
        OverwriteExist  bool   `json:"overwriteExist"`
}

// handleMigrateAPI 处理迁移 API
// GET: 获取所有任务列表
// POST: 创建新迁移任务
func (h *Handler) handleMigrateAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.listMigrateJobs(w, r)</span>
        case http.MethodPost:<span class="cov8" title="1">
                h.createMigrateJob(w, r)</span>
        default:<span class="cov8" title="1">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}

// listMigrateJobs 获取所有迁移任务
func (h *Handler) listMigrateJobs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        mgr := storage.GetMigrateManager(h.metadata, h.filestore)
        jobs := mgr.GetAllJobs()

        // 获取统计信息
        stats := mgr.GetJobStats()

        utils.WriteJSONResponse(w, map[string]interface{}{
                "jobs":  jobs,
                "stats": stats,
        })
}</span>

// createMigrateJob 创建迁移任务
func (h *Handler) createMigrateJob(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req MigrateRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        // 转换为 MigrateConfig
        <span class="cov8" title="1">cfg := storage.MigrateConfig{
                SourceEndpoint:  req.SourceEndpoint,
                SourceAccessKey: req.SourceAccessKey,
                SourceSecretKey: req.SourceSecretKey,
                SourceBucket:    req.SourceBucket,
                SourcePrefix:    req.SourcePrefix,
                SourceRegion:    req.SourceRegion,
                TargetBucket:    req.TargetBucket,
                TargetPrefix:    req.TargetPrefix,
                OverwriteExist:  req.OverwriteExist,
        }

        mgr := storage.GetMigrateManager(h.metadata, h.filestore)
        jobID, err := mgr.StartMigration(cfg)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "MigrationError", err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]interface{}{
                "success": true,
                "jobId":   jobID,
        })</span>
}

// handleMigrateJob 处理单个迁移任务操作
// GET /api/admin/migrate/{jobId}: 获取任务进度
// DELETE /api/admin/migrate/{jobId}: 取消任务
// POST /api/admin/migrate/validate: 验证连接配置
func (h *Handler) handleMigrateJob(w http.ResponseWriter, r *http.Request, path string) <span class="cov8" title="1">{
        // 特殊处理 validate 端点
        if path == "validate" </span><span class="cov8" title="1">{
                if r.Method == http.MethodPost </span><span class="cov8" title="1">{
                        h.validateMigrateConfig(w, r)
                }</span> else<span class="cov8" title="1"> {
                        utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // 处理任务 ID
        <span class="cov8" title="1">parts := strings.SplitN(path, "/", 2)
        jobID := parts[0]

        if jobID == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Job ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">mgr := storage.GetMigrateManager(h.metadata, h.filestore)

        // 检查任务是否存在
        progress := mgr.GetProgress(jobID)
        if progress == nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "NotFound", "Job not found", http.StatusNotFound)
                return
        }</span>

        // 处理子路由
        <span class="cov8" title="1">if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                action := parts[1]
                switch action </span>{
                case "cancel":<span class="cov8" title="1">
                        if r.Method == http.MethodPost </span><span class="cov8" title="1">{
                                h.cancelMigrateJob(w, r, jobID)
                        }</span> else<span class="cov8" title="1"> {
                                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                        }</span>
                default:<span class="cov8" title="1">
                        utils.WriteErrorResponse(w, "NotFound", "API endpoint not found", http.StatusNotFound)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        // 处理主路由
        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                utils.WriteJSONResponse(w, progress)</span>
        case http.MethodDelete:<span class="cov8" title="1">
                h.deleteMigrateJob(w, r, jobID)</span>
        default:<span class="cov0" title="0">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}

// validateMigrateConfig 验证迁移配置（连接测试）
func (h *Handler) validateMigrateConfig(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req MigrateRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        <span class="cov8" title="1">cfg := storage.MigrateConfig{
                SourceEndpoint:  req.SourceEndpoint,
                SourceAccessKey: req.SourceAccessKey,
                SourceSecretKey: req.SourceSecretKey,
                SourceBucket:    req.SourceBucket,
                SourceRegion:    req.SourceRegion,
        }

        mgr := storage.GetMigrateManager(h.metadata, h.filestore)
        err := mgr.ValidateMigrateConfig(cfg)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteJSONResponse(w, map[string]interface{}{
                        "valid":   false,
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">utils.WriteJSONResponse(w, map[string]interface{}{
                "valid":   true,
                "message": "Connection successful",
        })</span>
}

// cancelMigrateJob 取消迁移任务
func (h *Handler) cancelMigrateJob(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov8" title="1">{
        mgr := storage.GetMigrateManager(h.metadata, h.filestore)
        err := mgr.CancelMigration(jobID)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteErrorResponse(w, "CancelError", err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]bool{"success": true})</span>
}

// deleteMigrateJob 删除迁移任务记录
func (h *Handler) deleteMigrateJob(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov8" title="1">{
        mgr := storage.GetMigrateManager(h.metadata, h.filestore)
        err := mgr.DeleteJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteErrorResponse(w, "DeleteError", err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]bool{"success": true})</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package admin

import (
        "fmt"
        "io"
        "net/http"
        "path/filepath"
        "strings"
        "time"

        "sss/internal/storage"
        "sss/internal/utils"
)

// AdminObjectInfo 管理员 API 对象信息
type AdminObjectInfo struct {
        Key          string `json:"key"`
        Size         int64  `json:"size"`
        LastModified string `json:"last_modified"`
        ETag         string `json:"etag"`
}

// adminObjectsHandler 对象操作处理器（支持 GET 列出和 DELETE 删除）
func (h *Handler) adminObjectsHandler(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.adminListObjects(w, r, bucketName)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                h.adminDeleteObject(w, r, bucketName)</span>
        default:<span class="cov8" title="1">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}

// adminListObjects 列出桶中的对象
func (h *Handler) adminListObjects(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        prefix := r.URL.Query().Get("prefix")
        marker := r.URL.Query().Get("marker")
        maxKeys := 100

        result, err := h.metadata.ListObjects(bucketName, prefix, marker, "", maxKeys)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("list objects failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">objects := make([]AdminObjectInfo, 0, len(result.Contents))
        for _, obj := range result.Contents </span><span class="cov0" title="0">{
                objects = append(objects, AdminObjectInfo{
                        Key:          obj.Key,
                        Size:         obj.Size,
                        LastModified: obj.LastModified.Format(time.RFC3339),
                        ETag:         obj.ETag,
                })
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]interface{}{
                "objects":      objects,
                "is_truncated": result.IsTruncated,
                "next_marker":  result.NextMarker,
        })</span>
}

// adminDeleteObject 删除单个对象
// DELETE /api/admin/buckets/{bucket}/objects?key=xxx
func (h *Handler) adminDeleteObject(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        key := r.URL.Query().Get("key")
        if key == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "MissingParameter", "Missing 'key' parameter", http.StatusBadRequest)
                return
        }</span>

        // 安全检查：防止路径遍历
        <span class="cov8" title="1">if strings.Contains(key, "..") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Invalid key", http.StatusBadRequest)
                return
        }</span>

        // 获取对象元数据
        <span class="cov8" title="1">obj, err := h.metadata.GetObject(bucketName, key)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get object for delete failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if obj == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchKey, http.StatusNotFound, "")
                return
        }</span>

        // 删除文件
        <span class="cov8" title="1">if err := h.filestore.DeleteObject(obj.StoragePath); err != nil </span><span class="cov0" title="0">{
                utils.Error("delete file failed", "key", key, "error", err)
        }</span>

        // 删除元数据
        <span class="cov8" title="1">if err := h.metadata.DeleteObject(bucketName, key); err != nil </span><span class="cov0" title="0">{
                utils.Error("delete metadata failed", "key", key, "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]bool{"success": true})</span>
}

// adminUploadObject 上传对象
// POST /api/admin/buckets/{bucket}/upload?key=xxx
func (h *Handler) adminUploadObject(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">key := r.URL.Query().Get("key")
        if key == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "MissingParameter", "Missing 'key' parameter", http.StatusBadRequest)
                return
        }</span>

        // 安全检查：防止路径遍历
        <span class="cov8" title="1">if strings.Contains(key, "..") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Invalid key", http.StatusBadRequest)
                return
        }</span>

        // 解析 multipart form
        <span class="cov8" title="1">if err := r.ParseMultipartForm(32 &lt;&lt; 20); err != nil </span><span class="cov8" title="1">{ // 32MB
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        <span class="cov8" title="1">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteErrorResponse(w, "MissingFile", "No file uploaded", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // 确定 content type
        contentType := header.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        // 保存文件
        <span class="cov8" title="1">storagePath, etag, err := h.filestore.PutObject(bucketName, key, file, header.Size)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("save uploaded file failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 保存元数据
        <span class="cov8" title="1">obj := &amp;storage.Object{
                Bucket:       bucketName,
                Key:          key,
                Size:         header.Size,
                ETag:         etag,
                ContentType:  contentType,
                StoragePath:  storagePath,
                LastModified: time.Now(),
        }
        if err := h.metadata.PutObject(obj); err != nil </span><span class="cov0" title="0">{
                utils.Error("save object metadata failed", "error", err)
                // 回滚：删除已上传的文件
                h.filestore.DeleteObject(storagePath)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]interface{}{
                "success": true,
                "key":     key,
                "size":    header.Size,
                "etag":    etag,
        })</span>
}

// adminDownloadObject 下载对象
// GET /api/admin/buckets/{bucket}/download?key=xxx
func (h *Handler) adminDownloadObject(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">key := r.URL.Query().Get("key")
        if key == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "MissingParameter", "Missing 'key' parameter", http.StatusBadRequest)
                return
        }</span>

        // 安全检查：防止路径遍历
        <span class="cov8" title="1">if strings.Contains(key, "..") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Invalid key", http.StatusBadRequest)
                return
        }</span>

        // 获取对象元数据
        <span class="cov8" title="1">obj, err := h.metadata.GetObject(bucketName, key)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get object for download failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if obj == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchKey, http.StatusNotFound, "")
                return
        }</span>

        // 读取文件
        <span class="cov8" title="1">file, err := h.filestore.GetObject(obj.StoragePath)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("read file for download failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // 设置响应头
        fileName := filepath.Base(key)
        w.Header().Set("Content-Type", obj.ContentType)
        w.Header().Set("Content-Disposition", "attachment; filename=\""+fileName+"\"")
        w.Header().Set("Content-Length", fmt.Sprintf("%d", obj.Size))
        w.Header().Set("ETag", obj.ETag)

        // 发送文件内容
        io.Copy(w, file)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package admin

import (
        "io"
        "net/http"
        "path/filepath"
        "strings"
        "time"

        "sss/internal/auth"
        "sss/internal/storage"
        "sss/internal/utils"
)

// PreviewResponse 预览响应
type PreviewResponse struct {
        Type        string `json:"type"`                // text, image, video, audio, pdf, office, binary
        MimeType    string `json:"mime_type"`           // MIME 类型
        Size        int64  `json:"size"`                // 文件大小
        Content     string `json:"content,omitempty"`   // 文本内容（仅文本类型）
        URL         string `json:"url,omitempty"`       // 预签名 URL（用于直接预览）
        Previewable bool   `json:"previewable"`         // 是否可预览
        Truncated   bool   `json:"truncated,omitempty"` // 内容是否被截断
        Lines       int    `json:"lines,omitempty"`     // 文本行数
        Encoding    string `json:"encoding,omitempty"`  // 文本编码
}

// 预览大小限制
const (
        maxPreviewSize   = 1024 * 1024 // 1MB - 文本预览最大大小
        maxPreviewLines  = 1000        // 最大预览行数
        previewURLExpiry = 15          // 预签名 URL 有效期（分钟）
)

// 可预览的文本文件扩展名
var textExtensions = map[string]bool{
        ".txt": true, ".md": true, ".markdown": true, ".rst": true,
        ".json": true, ".xml": true, ".yaml": true, ".yml": true, ".toml": true,
        ".html": true, ".htm": true, ".css": true, ".scss": true, ".less": true,
        ".js": true, ".ts": true, ".jsx": true, ".tsx": true, ".vue": true, ".svelte": true,
        ".go": true, ".py": true, ".rb": true, ".php": true, ".java": true, ".kt": true,
        ".c": true, ".cpp": true, ".h": true, ".hpp": true, ".cs": true,
        ".rs": true, ".swift": true, ".m": true, ".mm": true,
        ".sh": true, ".bash": true, ".zsh": true, ".fish": true, ".ps1": true, ".bat": true, ".cmd": true,
        ".sql": true, ".graphql": true, ".gql": true,
        ".dockerfile": true, ".gitignore": true, ".editorconfig": true,
        ".env": true, ".ini": true, ".conf": true, ".cfg": true, ".properties": true,
        ".log": true, ".csv": true, ".tsv": true,
        ".makefile": true, ".cmake": true,
}

// 可预览的图片扩展名
var imageExtensions = map[string]bool{
        ".jpg": true, ".jpeg": true, ".png": true, ".gif": true, ".webp": true,
        ".svg": true, ".ico": true, ".bmp": true, ".tiff": true, ".tif": true,
}

// 可预览的视频扩展名
var videoExtensions = map[string]bool{
        ".mp4": true, ".webm": true, ".ogg": true, ".ogv": true, ".mov": true,
        ".m4v": true, ".avi": true, ".mkv": true,
}

// 可预览的音频扩展名
var audioExtensions = map[string]bool{
        ".mp3": true, ".wav": true, ".ogg": true, ".oga": true, ".m4a": true,
        ".flac": true, ".aac": true, ".wma": true,
}

// PDF 扩展名
var pdfExtensions = map[string]bool{
        ".pdf": true,
}

// previewObject 预览对象
// GET /api/admin/buckets/{bucket}/preview?key=xxx
func (h *Handler) previewObject(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        // 获取对象 key
        <span class="cov8" title="1">key := r.URL.Query().Get("key")
        if key == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "MissingParameter", "Missing 'key' parameter", http.StatusBadRequest)
                return
        }</span>

        // 安全检查：防止路径遍历
        <span class="cov8" title="1">if strings.Contains(key, "..") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "Invalid key", http.StatusBadRequest)
                return
        }</span>

        // 获取对象元数据
        <span class="cov8" title="1">obj, err := h.metadata.GetObject(bucketName, key)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get object for preview failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if obj == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchKey, http.StatusNotFound, "")
                return
        }</span>

        // 获取文件扩展名
        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(key))
        // 特殊处理无扩展名的文件（如 Dockerfile, Makefile 等）
        if ext == "" </span><span class="cov8" title="1">{
                baseName := strings.ToLower(filepath.Base(key))
                if baseName == "dockerfile" || baseName == "makefile" || baseName == "rakefile" ||
                        baseName == "gemfile" || baseName == "vagrantfile" || baseName == "jenkinsfile" </span><span class="cov8" title="1">{
                        ext = "." + baseName
                }</span>
        }

        // 确定文件类型
        <span class="cov8" title="1">resp := PreviewResponse{
                Size:     obj.Size,
                MimeType: getMimeType(ext),
        }

        switch </span>{
        case textExtensions[ext]:<span class="cov8" title="1">
                resp.Type = "text"
                resp.Previewable = true
                h.handleTextPreview(w, &amp;resp, obj, bucketName, key)
                return</span>

        case imageExtensions[ext]:<span class="cov8" title="1">
                resp.Type = "image"
                resp.Previewable = true
                resp.URL = h.generatePreviewURL(bucketName, key)</span>

        case videoExtensions[ext]:<span class="cov8" title="1">
                resp.Type = "video"
                resp.Previewable = true
                resp.URL = h.generatePreviewURL(bucketName, key)</span>

        case audioExtensions[ext]:<span class="cov8" title="1">
                resp.Type = "audio"
                resp.Previewable = true
                resp.URL = h.generatePreviewURL(bucketName, key)</span>

        case pdfExtensions[ext]:<span class="cov8" title="1">
                resp.Type = "pdf"
                resp.Previewable = true
                resp.URL = h.generatePreviewURL(bucketName, key)</span>

        default:<span class="cov8" title="1">
                resp.Type = "binary"
                resp.Previewable = false
                resp.URL = h.generatePreviewURL(bucketName, key)</span>
        }

        <span class="cov8" title="1">utils.WriteJSONResponse(w, resp)</span>
}

// handleTextPreview 处理文本文件预览
func (h *Handler) handleTextPreview(w http.ResponseWriter, resp *PreviewResponse, obj *storage.Object, bucket, key string) <span class="cov8" title="1">{
        // 检查文件大小
        if obj.Size &gt; maxPreviewSize </span><span class="cov0" title="0">{
                // 文件过大，只读取前 1MB
                resp.Truncated = true
        }</span>

        // 读取文件内容
        <span class="cov8" title="1">file, err := h.filestore.GetObject(obj.StoragePath)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("open file for preview failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // 读取内容（限制大小）
        readSize := obj.Size
        if readSize &gt; maxPreviewSize </span><span class="cov0" title="0">{
                readSize = maxPreviewSize
        }</span>

        <span class="cov8" title="1">content := make([]byte, readSize)
        n, err := io.ReadFull(file, content)
        if err != nil &amp;&amp; err != io.EOF &amp;&amp; err != io.ErrUnexpectedEOF </span><span class="cov0" title="0">{
                utils.Error("read file for preview failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">content = content[:n]

        // 检测编码（简单检测是否为 UTF-8）
        resp.Encoding = "utf-8"
        if !isValidUTF8(content) </span><span class="cov8" title="1">{
                resp.Encoding = "binary"
                resp.Type = "binary"
                resp.Previewable = false
                resp.Content = ""
                resp.URL = h.generatePreviewURL(bucket, key)
                utils.WriteJSONResponse(w, resp)
                return
        }</span>

        // 转换为字符串并限制行数
        <span class="cov8" title="1">text := string(content)
        lines := strings.Split(text, "\n")
        resp.Lines = len(lines)

        if len(lines) &gt; maxPreviewLines </span><span class="cov0" title="0">{
                lines = lines[:maxPreviewLines]
                resp.Truncated = true
        }</span>

        <span class="cov8" title="1">resp.Content = strings.Join(lines, "\n")
        utils.WriteJSONResponse(w, resp)</span>
}

// generatePreviewURL 生成预览用的预签名 URL
func (h *Handler) generatePreviewURL(bucket, key string) string <span class="cov8" title="1">{
        opts := &amp;auth.PresignOptions{
                Expires: time.Duration(previewURLExpiry) * time.Minute,
        }
        return auth.GeneratePresignedURLWithOptions("GET", bucket, key, opts)
}</span>

// getMimeType 根据扩展名获取 MIME 类型
func getMimeType(ext string) string <span class="cov8" title="1">{
        mimeTypes := map[string]string{
                // 文本
                ".txt":      "text/plain",
                ".md":       "text/markdown",
                ".markdown": "text/markdown",
                ".json":     "application/json",
                ".xml":      "application/xml",
                ".yaml":     "text/yaml",
                ".yml":      "text/yaml",
                ".html":     "text/html",
                ".htm":      "text/html",
                ".css":      "text/css",
                ".js":       "application/javascript",
                ".ts":       "application/typescript",
                ".go":       "text/x-go",
                ".py":       "text/x-python",
                ".rb":       "text/x-ruby",
                ".php":      "text/x-php",
                ".java":     "text/x-java",
                ".c":        "text/x-c",
                ".cpp":      "text/x-c++",
                ".h":        "text/x-c",
                ".hpp":      "text/x-c++",
                ".cs":       "text/x-csharp",
                ".rs":       "text/x-rust",
                ".swift":    "text/x-swift",
                ".sql":      "text/x-sql",
                ".sh":       "text/x-shellscript",
                ".bash":     "text/x-shellscript",
                ".log":      "text/plain",
                ".csv":      "text/csv",

                // 图片
                ".jpg":  "image/jpeg",
                ".jpeg": "image/jpeg",
                ".png":  "image/png",
                ".gif":  "image/gif",
                ".webp": "image/webp",
                ".svg":  "image/svg+xml",
                ".ico":  "image/x-icon",
                ".bmp":  "image/bmp",

                // 视频
                ".mp4":  "video/mp4",
                ".webm": "video/webm",
                ".ogg":  "video/ogg",
                ".mov":  "video/quicktime",
                ".avi":  "video/x-msvideo",
                ".mkv":  "video/x-matroska",

                // 音频
                ".mp3":  "audio/mpeg",
                ".wav":  "audio/wav",
                ".m4a":  "audio/mp4",
                ".flac": "audio/flac",
                ".aac":  "audio/aac",

                // PDF
                ".pdf": "application/pdf",
        }

        if mime, ok := mimeTypes[ext]; ok </span><span class="cov8" title="1">{
                return mime
        }</span>
        <span class="cov8" title="1">return "application/octet-stream"</span>
}

// isValidUTF8 检查字节是否为有效的 UTF-8 编码
func isValidUTF8(data []byte) bool <span class="cov8" title="1">{
        // 检查是否包含 NULL 字节（二进制文件通常包含）
        for _, b := range data </span><span class="cov8" title="1">{
                if b == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // 使用标准库检查 UTF-8
        <span class="cov8" title="1">for i := 0; i &lt; len(data); </span><span class="cov8" title="1">{
                r, size := decodeRune(data[i:])
                if r == 0xFFFD &amp;&amp; size == 1 </span><span class="cov8" title="1">{
                        // 无效的 UTF-8 序列
                        return false
                }</span>
                <span class="cov8" title="1">i += size</span>
        }
        <span class="cov8" title="1">return true</span>
}

// decodeRune 解码 UTF-8 字节序列
func decodeRune(p []byte) (r rune, size int) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov8" title="1">{
                return 0xFFFD, 0
        }</span>

        <span class="cov8" title="1">c := p[0]
        if c &lt; 0x80 </span><span class="cov8" title="1">{
                return rune(c), 1
        }</span>

        // 多字节序列
        <span class="cov8" title="1">var n int
        switch </span>{
        case c &lt; 0xC0:<span class="cov8" title="1">
                return 0xFFFD, 1</span> // 无效的起始字节
        case c &lt; 0xE0:<span class="cov8" title="1">
                n = 2</span>
        case c &lt; 0xF0:<span class="cov8" title="1">
                n = 3</span>
        case c &lt; 0xF8:<span class="cov0" title="0">
                n = 4</span>
        default:<span class="cov8" title="1">
                return 0xFFFD, 1</span>
        }

        <span class="cov8" title="1">if len(p) &lt; n </span><span class="cov8" title="1">{
                return 0xFFFD, 1
        }</span>

        // 验证后续字节
        <span class="cov8" title="1">for i := 1; i &lt; n; i++ </span><span class="cov8" title="1">{
                if p[i]&amp;0xC0 != 0x80 </span><span class="cov8" title="1">{
                        return 0xFFFD, 1
                }</span>
        }

        // 解码
        <span class="cov8" title="1">switch n </span>{
        case 2:<span class="cov8" title="1">
                r = rune(p[0]&amp;0x1F)&lt;&lt;6 | rune(p[1]&amp;0x3F)</span>
        case 3:<span class="cov8" title="1">
                r = rune(p[0]&amp;0x0F)&lt;&lt;12 | rune(p[1]&amp;0x3F)&lt;&lt;6 | rune(p[2]&amp;0x3F)</span>
        case 4:<span class="cov0" title="0">
                r = rune(p[0]&amp;0x07)&lt;&lt;18 | rune(p[1]&amp;0x3F)&lt;&lt;12 | rune(p[2]&amp;0x3F)&lt;&lt;6 | rune(p[3]&amp;0x3F)</span>
        }

        <span class="cov8" title="1">return r, n</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package admin

import (
        "crypto/rand"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/hex"
        "net/http"
        "sync"
        "time"

        "sss/internal/config"
        "sss/internal/storage"
        "sss/internal/utils"
)

// LoginAttempt 登录尝试记录
type LoginAttempt struct {
        FailCount int       // 失败次数
        LastFail  time.Time // 最后失败时间
        LockedAt  time.Time // 锁定时间
}

// LoginRateLimiter 登录速率限制器
type LoginRateLimiter struct {
        mu       sync.RWMutex
        attempts map[string]*LoginAttempt // IP -&gt; 尝试记录
}

// 速率限制配置
const (
        maxLoginAttempts  = 5               // 最大失败次数
        lockDuration      = 15 * time.Minute // 锁定时长
        attemptResetAfter = 30 * time.Minute // 失败计数重置时间
)

var loginLimiter = &amp;LoginRateLimiter{
        attempts: make(map[string]*LoginAttempt),
}

// IsBlocked 检查 IP 是否被锁定
func (l *LoginRateLimiter) IsBlocked(ip string) (bool, time.Duration) <span class="cov8" title="1">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        attempt, exists := l.attempts[ip]
        if !exists </span><span class="cov8" title="1">{
                return false, 0
        }</span>

        // 检查是否在锁定期内
        <span class="cov8" title="1">if !attempt.LockedAt.IsZero() </span><span class="cov8" title="1">{
                remaining := lockDuration - time.Since(attempt.LockedAt)
                if remaining &gt; 0 </span><span class="cov8" title="1">{
                        return true, remaining
                }</span>
        }

        <span class="cov8" title="1">return false, 0</span>
}

// RecordFailure 记录登录失败
func (l *LoginRateLimiter) RecordFailure(ip string) (blocked bool, remaining time.Duration) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        attempt, exists := l.attempts[ip]
        if !exists </span><span class="cov8" title="1">{
                attempt = &amp;LoginAttempt{}
                l.attempts[ip] = attempt
        }</span>

        // 如果距离上次失败超过重置时间，重置计数
        <span class="cov8" title="1">if time.Since(attempt.LastFail) &gt; attemptResetAfter </span><span class="cov8" title="1">{
                attempt.FailCount = 0
                attempt.LockedAt = time.Time{}
        }</span>

        <span class="cov8" title="1">attempt.FailCount++
        attempt.LastFail = time.Now()

        // 达到最大失败次数，锁定账户
        if attempt.FailCount &gt;= maxLoginAttempts </span><span class="cov8" title="1">{
                attempt.LockedAt = time.Now()
                return true, lockDuration
        }</span>

        <span class="cov8" title="1">return false, 0</span>
}

// RecordSuccess 记录登录成功（清除失败记录）
func (l *LoginRateLimiter) RecordSuccess(ip string) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        delete(l.attempts, ip)
}</span>

// Cleanup 清理过期记录（可选，定期调用）
func (l *LoginRateLimiter) Cleanup() <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        now := time.Now()
        for ip, attempt := range l.attempts </span><span class="cov8" title="1">{
                // 清理超过1小时未活动的记录
                if now.Sub(attempt.LastFail) &gt; time.Hour </span><span class="cov8" title="1">{
                        delete(l.attempts, ip)
                }</span>
        }
}

// Session 管理员会话
type Session struct {
        Token     string
        ExpiresAt time.Time
}

// SessionStore 会话存储
type SessionStore struct {
        mu       sync.RWMutex
        sessions map[string]*Session
}

var sessionStore = &amp;SessionStore{
        sessions: make(map[string]*Session),
}

// 会话有效期 24 小时
const sessionDuration = 24 * time.Hour

// CreateSession 创建会话
func (s *SessionStore) CreateSession() string <span class="cov8" title="1">{
        token := generateSessionToken()
        s.mu.Lock()
        defer s.mu.Unlock()

        // 清理过期会话
        now := time.Now()
        for k, v := range s.sessions </span><span class="cov8" title="1">{
                if now.After(v.ExpiresAt) </span><span class="cov0" title="0">{
                        delete(s.sessions, k)
                }</span>
        }

        <span class="cov8" title="1">s.sessions[token] = &amp;Session{
                Token:     token,
                ExpiresAt: time.Now().Add(sessionDuration),
        }
        return token</span>
}

// ValidateSession 验证会话
func (s *SessionStore) ValidateSession(token string) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        session, exists := s.sessions[token]
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return time.Now().Before(session.ExpiresAt)</span>
}

// DeleteSession 删除会话
func (s *SessionStore) DeleteSession(token string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.sessions, token)
}</span>

// generateSessionToken 生成会话令牌
func generateSessionToken() string <span class="cov8" title="1">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // crypto/rand 不可用是严重错误，应立即终止
                panic("crypto/rand unavailable: " + err.Error())</span>
        }
        <span class="cov8" title="1">hash := sha256.Sum256(bytes)
        return hex.EncodeToString(hash[:])</span>
}

// checkAdminAuth 检查管理员认证
// checkAdminAuth 检查管理员认证
func (h *Handler) checkAdminAuth(r *http.Request) bool <span class="cov8" title="1">{
        token := r.Header.Get("X-Admin-Token")
        if token == "" </span><span class="cov8" title="1">{
                // 尝试从 cookie 获取
                if cookie, err := r.Cookie("admin_token"); err == nil </span><span class="cov8" title="1">{
                        token = cookie.Value
                }</span>
        }
        <span class="cov8" title="1">return token != "" &amp;&amp; sessionStore.ValidateSession(token)</span>
}

// AdminLoginRequest 管理员登录请求
type AdminLoginRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

// AdminLoginResponse 管理员登录响应
type AdminLoginResponse struct {
        Success         bool   `json:"success"`
        Token           string `json:"token,omitempty"`
        Message         string `json:"message,omitempty"`
        AccessKeyId     string `json:"accessKeyId,omitempty"`
        SecretAccessKey string `json:"secretAccessKey,omitempty"`
}

// handleAdminLogin 处理管理员登录
func (h *Handler) handleAdminLogin(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        // 获取客户端 IP
        <span class="cov8" title="1">clientIP := utils.GetClientIP(r)

        // 检查是否被速率限制锁定
        if blocked, remaining := loginLimiter.IsBlocked(clientIP); blocked </span><span class="cov0" title="0">{
                h.Audit(r, storage.AuditActionLoginFailed, "", "", false, map[string]string{
                        "reason": "IP 被临时锁定",
                        "ip":     clientIP,
                })
                utils.WriteErrorResponse(w, "TooManyRequests",
                        "登录尝试次数过多，请 "+remaining.Round(time.Minute).String()+" 后重试",
                        http.StatusTooManyRequests)
                return
        }</span>

        // 检查系统是否已安装
        <span class="cov8" title="1">if !h.metadata.IsInstalled() </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "NotInstalled", "系统尚未安装，请先完成安装", http.StatusForbidden)
                return
        }</span>

        <span class="cov8" title="1">var req AdminLoginRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        // 验证用户名
        <span class="cov8" title="1">usernameMatch := subtle.ConstantTimeCompare(
                []byte(req.Username),
                []byte(h.metadata.GetAdminUsername()),
        ) == 1

        // 验证密码（所有密码都存储在数据库中，使用 bcrypt 验证）
        passwordMatch := h.metadata.VerifyAdminPassword(req.Password)

        if !usernameMatch || !passwordMatch </span><span class="cov8" title="1">{
                // 记录失败并检查是否需要锁定
                blocked, remaining := loginLimiter.RecordFailure(clientIP)

                // 记录登录失败
                extra := map[string]string{
                        "reason": "用户名或密码错误",
                        "ip":     clientIP,
                }
                if blocked </span><span class="cov0" title="0">{
                        extra["locked_for"] = remaining.String()
                }</span>
                <span class="cov8" title="1">h.Audit(r, storage.AuditActionLoginFailed, req.Username, "", false, extra)

                if blocked </span><span class="cov0" title="0">{
                        utils.WriteErrorResponse(w, "TooManyRequests",
                                "登录尝试次数过多，账户已被临时锁定 "+remaining.Round(time.Minute).String(),
                                http.StatusTooManyRequests)
                }</span> else<span class="cov8" title="1"> {
                        utils.WriteErrorResponse(w, "Unauthorized", "用户名或密码错误", http.StatusUnauthorized)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // 登录成功，清除失败记录
        <span class="cov8" title="1">loginLimiter.RecordSuccess(clientIP)

        // 创建会话
        token := sessionStore.CreateSession()

        // 记录登录成功
        h.Audit(r, storage.AuditActionLogin, req.Username, "", true, nil)

        // 设置 cookie（根据请求协议设置 Secure 标志）
        isHTTPS := r.TLS != nil || r.Header.Get("X-Forwarded-Proto") == "https"
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "admin_token",
                Value:    token,
                Path:     "/",
                HttpOnly: true,
                Secure:   isHTTPS,
                MaxAge:   int(sessionDuration.Seconds()),
                SameSite: http.SameSiteStrictMode,
        })

        // 获取 API Key
        accessKeyID, secretAccessKey := h.metadata.GetAuthConfig()
        if accessKeyID == "" </span><span class="cov0" title="0">{
                // 兼容旧配置
                accessKeyID = config.Global.Auth.AccessKeyID
                secretAccessKey = config.Global.Auth.SecretAccessKey
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, AdminLoginResponse{
                Success:         true,
                Token:           token,
                AccessKeyId:     accessKeyID,
                SecretAccessKey: secretAccessKey,
        })</span>
}

// handleAdminLogout 处理管理员登出
func (h *Handler) handleAdminLogout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">token := r.Header.Get("X-Admin-Token")
        if token == "" </span><span class="cov8" title="1">{
                if cookie, err := r.Cookie("admin_token"); err == nil </span><span class="cov0" title="0">{
                        token = cookie.Value
                }</span>
        }

        <span class="cov8" title="1">if token != "" </span><span class="cov8" title="1">{
                sessionStore.DeleteSession(token)
        }</span>

        // 记录登出
        <span class="cov8" title="1">h.Audit(r, storage.AuditActionLogout, "admin", "", true, nil)

        // 清除 cookie
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "admin_token",
                Value:    "",
                Path:     "/",
                HttpOnly: true,
                MaxAge:   -1,
        })

        utils.WriteJSONResponse(w, map[string]bool{"success": true})</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package admin

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "sss/internal/config"
        "sss/internal/storage"
        "sss/internal/utils"
)

// SettingsResponse 系统设置响应
type SettingsResponse struct {
        Runtime  RuntimeSettings  `json:"runtime"`  // 运行时参数（只读）
        Storage  StorageSettings  `json:"storage"`  // 存储设置（可修改）
        Security SecuritySettings `json:"security"` // 安全设置（可修改）
        System   SystemInfo       `json:"system"`   // 系统信息（只读）
}

// SecuritySettings 安全设置（可在线修改）
type SecuritySettings struct {
        CORSOrigin    string `json:"cors_origin"`    // CORS 允许的来源，默认 "*"
        PresignScheme string `json:"presign_scheme"` // 预签名URL协议，"http" 或 "https"
}

// RuntimeSettings 运行时参数（启动时确定，不可在线修改）
type RuntimeSettings struct {
        Host     string `json:"host"`      // 监听地址
        Port     int    `json:"port"`      // 监听端口
        DataPath string `json:"data_path"` // 数据目录
        DBPath   string `json:"db_path"`   // 数据库路径
}

// StorageSettings 存储设置（可在线修改）
type StorageSettings struct {
        Region        string `json:"region"`          // S3 区域
        MaxObjectSize int64  `json:"max_object_size"` // 最大对象大小
        MaxUploadSize int64  `json:"max_upload_size"` // 最大上传大小
}

// SystemInfo 系统信息
type SystemInfo struct {
        Installed   bool   `json:"installed"`
        InstalledAt string `json:"installed_at"`
        Version     string `json:"version"`
}

// handleSettings 处理系统设置 API
func (h *Handler) handleSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.getSettings(w, r)</span>
        case http.MethodPut:<span class="cov8" title="1">
                h.updateSettings(w, r)</span>
        default:<span class="cov8" title="1">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}

// getSettings 获取系统设置
func (h *Handler) getSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // 运行时参数（来自命令行，只读）
        runtime := RuntimeSettings{
                Host:     config.Global.Server.Host,
                Port:     config.Global.Server.Port,
                DataPath: config.Global.Storage.DataPath,
                DBPath:   config.Global.Storage.DBPath,
        }

        // 存储设置（可在线修改）
        storage_ := StorageSettings{
                Region:        config.Global.Server.Region,
                MaxObjectSize: config.Global.Storage.MaxObjectSize,
                MaxUploadSize: config.Global.Storage.MaxUploadSize,
        }

        // 安全设置（可在线修改）
        security := SecuritySettings{
                CORSOrigin:    config.Global.Security.CORSOrigin,
                PresignScheme: config.Global.Security.PresignScheme,
        }
        // 确保有默认值
        if security.CORSOrigin == "" </span><span class="cov0" title="0">{
                security.CORSOrigin = "*"
        }</span>
        <span class="cov8" title="1">if security.PresignScheme == "" </span><span class="cov0" title="0">{
                security.PresignScheme = "http"
        }</span>

        // 系统信息
        <span class="cov8" title="1">installedAt, _ := h.metadata.GetSetting(storage.SettingSystemInstalledAt)
        version, _ := h.metadata.GetSetting(storage.SettingSystemVersion)

        resp := SettingsResponse{
                Runtime:  runtime,
                Storage:  storage_,
                Security: security,
                System: SystemInfo{
                        Installed:   h.metadata.IsInstalled(),
                        InstalledAt: installedAt,
                        Version:     version,
                },
        }

        utils.WriteJSONResponse(w, resp)</span>
}

// UpdateSettingsRequest 更新设置请求（只包含可修改的字段）
type UpdateSettingsRequest struct {
        Region        *string `json:"region,omitempty"`
        MaxObjectSize *int64  `json:"max_object_size,omitempty"`
        MaxUploadSize *int64  `json:"max_upload_size,omitempty"`
        CORSOrigin    *string `json:"cors_origin,omitempty"`
        PresignScheme *string `json:"presign_scheme,omitempty"`
}

// updateSettings 更新系统设置
func (h *Handler) updateSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req UpdateSettingsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidRequest", "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // 更新 S3 区域
        <span class="cov8" title="1">if req.Region != nil &amp;&amp; *req.Region != "" </span><span class="cov8" title="1">{
                if err := h.metadata.SetSetting(storage.SettingServerRegion, *req.Region); err != nil </span><span class="cov0" title="0">{
                        utils.WriteErrorResponse(w, "InternalError", err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">config.Global.Server.Region = *req.Region</span>
        }

        // 更新最大对象大小
        <span class="cov8" title="1">if req.MaxObjectSize != nil &amp;&amp; *req.MaxObjectSize &gt; 0 </span><span class="cov8" title="1">{
                if err := h.metadata.SetSetting(storage.SettingStorageMaxObjectSize, strconv.FormatInt(*req.MaxObjectSize, 10)); err != nil </span><span class="cov0" title="0">{
                        utils.WriteErrorResponse(w, "InternalError", err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">config.Global.Storage.MaxObjectSize = *req.MaxObjectSize</span>
        }

        // 更新最大上传大小
        <span class="cov8" title="1">if req.MaxUploadSize != nil &amp;&amp; *req.MaxUploadSize &gt; 0 </span><span class="cov8" title="1">{
                if err := h.metadata.SetSetting(storage.SettingStorageMaxUploadSize, strconv.FormatInt(*req.MaxUploadSize, 10)); err != nil </span><span class="cov0" title="0">{
                        utils.WriteErrorResponse(w, "InternalError", err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">config.Global.Storage.MaxUploadSize = *req.MaxUploadSize</span>
        }

        // 更新 CORS 来源
        <span class="cov8" title="1">if req.CORSOrigin != nil </span><span class="cov8" title="1">{
                // 允许设置为空（将使用默认值 "*"），或设置为具体值
                corsOrigin := *req.CORSOrigin
                if corsOrigin == "" </span><span class="cov8" title="1">{
                        corsOrigin = "*"
                }</span>
                <span class="cov8" title="1">if err := h.metadata.SetSetting(storage.SettingSecurityCORSOrigin, corsOrigin); err != nil </span><span class="cov0" title="0">{
                        utils.WriteErrorResponse(w, "InternalError", err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">config.Global.Security.CORSOrigin = corsOrigin</span>
        }

        // 更新预签名URL协议
        <span class="cov8" title="1">if req.PresignScheme != nil &amp;&amp; *req.PresignScheme != "" </span><span class="cov8" title="1">{
                scheme := *req.PresignScheme
                // 验证协议值
                if scheme != "http" &amp;&amp; scheme != "https" </span><span class="cov8" title="1">{
                        utils.WriteErrorResponse(w, "InvalidParameter", "presign_scheme 必须是 'http' 或 'https'", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">if err := h.metadata.SetSetting(storage.SettingSecurityPresignScheme, scheme); err != nil </span><span class="cov0" title="0">{
                        utils.WriteErrorResponse(w, "InternalError", err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">config.Global.Security.PresignScheme = scheme</span>
        }

        // 记录审计日志
        <span class="cov8" title="1">h.Audit(r, storage.AuditActionSettingsUpdate, "admin", "system", true, "更新系统设置")

        // 返回更新后的设置
        h.getSettings(w, r)</span>
}

// handleChangePassword 修改管理员密码
func (h *Handler) handleChangePassword(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">var req struct {
                OldPassword string `json:"old_password"`
                NewPassword string `json:"new_password"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidRequest", "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // 验证必填字段
        <span class="cov8" title="1">req.OldPassword = strings.TrimSpace(req.OldPassword)
        req.NewPassword = strings.TrimSpace(req.NewPassword)
        if req.OldPassword == "" || req.NewPassword == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidRequest", "密码不能为空", http.StatusBadRequest)
                return
        }</span>

        // 使用统一的密码复杂度验证
        <span class="cov8" title="1">if err := storage.ValidatePassword(req.NewPassword); err != nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidRequest", err.Error(), http.StatusBadRequest)
                return
        }</span>

        // 验证旧密码
        <span class="cov8" title="1">if !h.metadata.VerifyAdminPassword(req.OldPassword) </span><span class="cov8" title="1">{
                h.Audit(r, storage.AuditActionPasswordChange, "admin", "system", false, "旧密码验证失败")
                utils.WriteErrorResponse(w, "Unauthorized", "旧密码错误", http.StatusUnauthorized)
                return
        }</span>

        // 设置新密码
        <span class="cov8" title="1">if err := h.metadata.SetAdminPassword(req.NewPassword); err != nil </span><span class="cov0" title="0">{
                utils.WriteErrorResponse(w, "InternalError", err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // 记录审计日志
        <span class="cov8" title="1">h.Audit(r, storage.AuditActionPasswordChange, "admin", "system", true, "管理员密码已更改")

        utils.WriteJSONResponse(w, map[string]interface{}{
                "success": true,
                "message": "密码修改成功",
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package admin

import (
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "sss/internal/auth"
        "sss/internal/config"
        "sss/internal/storage"
        "sss/internal/utils"
)

// 密码重置文件路径
// resetPasswordFile 密码重置标记文件路径（可在测试中修改）
var resetPasswordFile = "./data/.reset_password"

// SetupRequest 安装请求
type SetupRequest struct {
        AdminUsername   string `json:"admin_username"`
        AdminPassword   string `json:"admin_password"`
        ServerHost      string `json:"server_host"`
        ServerPort      string `json:"server_port"`
        ServerRegion    string `json:"server_region"`
        StorageDataPath string `json:"storage_data_path"`
}

// SetupResponse 安装响应
type SetupResponse struct {
        Success         bool   `json:"success"`
        Message         string `json:"message,omitempty"`
        AccessKeyID     string `json:"access_key_id,omitempty"`
        SecretAccessKey string `json:"secret_access_key,omitempty"`
}

// SystemStatusResponse 系统状态响应
type SystemStatusResponse struct {
        Installed   bool   `json:"installed"`
        InstalledAt string `json:"installed_at,omitempty"`
        Version     string `json:"version"`
}

// ResetPasswordCheckResponse 密码重置检测响应
type ResetPasswordCheckResponse struct {
        FileExists bool   `json:"file_exists"`
        FilePath   string `json:"file_path"`
        Command    string `json:"command"`
}

// ResetPasswordRequest 密码重置请求
type ResetPasswordRequest struct {
        NewPassword string `json:"new_password"`
}

// handleSetupAPI 处理安装相关 API
func (h *Handler) handleSetupAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := strings.TrimPrefix(r.URL.Path, "/api/setup")
        path = strings.TrimPrefix(path, "/")

        switch </span>{
        case path == "" || path == "status":<span class="cov8" title="1">
                h.handleSystemStatus(w, r)</span>
        case path == "install":<span class="cov8" title="1">
                h.handleInstall(w, r)</span>
        case path == "reset-password/check":<span class="cov8" title="1">
                h.handleResetPasswordCheck(w, r)</span>
        case path == "reset-password":<span class="cov8" title="1">
                h.handleResetPassword(w, r)</span>
        default:<span class="cov8" title="1">
                utils.WriteErrorResponse(w, "NotFound", "API endpoint not found", http.StatusNotFound)</span>
        }
}

// handleSystemStatus 获取系统状态
func (h *Handler) handleSystemStatus(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">installed := h.metadata.IsInstalled()
        var installedAt string
        if installed </span><span class="cov8" title="1">{
                installedAt, _ = h.metadata.GetSetting(storage.SettingSystemInstalledAt)
        }</span>

        <span class="cov8" title="1">version, _ := h.metadata.GetSetting(storage.SettingSystemVersion)
        if version == "" </span><span class="cov8" title="1">{
                version = "1.1.0"
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, SystemStatusResponse{
                Installed:   installed,
                InstalledAt: installedAt,
                Version:     version,
        })</span>
}

// handleInstall 处理安装请求
func (h *Handler) handleInstall(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        // 检查是否已安装
        <span class="cov8" title="1">if h.metadata.IsInstalled() </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "AlreadyInstalled", "系统已安装，无法重复安装", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var req SetupRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        // 验证必填参数
        <span class="cov8" title="1">if req.AdminUsername == "" </span><span class="cov8" title="1">{
                req.AdminUsername = "admin"
        }</span>
        <span class="cov8" title="1">if req.AdminPassword == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "管理员密码不能为空", http.StatusBadRequest)
                return
        }</span>
        // 使用统一的密码复杂度验证
        <span class="cov8" title="1">if err := storage.ValidatePassword(req.AdminPassword); err != nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", err.Error(), http.StatusBadRequest)
                return
        }</span>

        // 设置默认值
        <span class="cov8" title="1">if req.ServerHost == "" </span><span class="cov8" title="1">{
                req.ServerHost = "0.0.0.0"
        }</span>
        <span class="cov8" title="1">if req.ServerPort == "" </span><span class="cov8" title="1">{
                req.ServerPort = "8080"
        }</span>
        <span class="cov8" title="1">if req.ServerRegion == "" </span><span class="cov8" title="1">{
                req.ServerRegion = "us-east-1"
        }</span>
        <span class="cov8" title="1">if req.StorageDataPath == "" </span><span class="cov8" title="1">{
                req.StorageDataPath = "./data/buckets"
        }</span>

        // 初始化配置
        <span class="cov8" title="1">if err := h.metadata.InitDefaultSettings(req.AdminUsername, req.AdminPassword); err != nil </span><span class="cov0" title="0">{
                utils.Error("初始化配置失败", "error", err)
                utils.WriteErrorResponse(w, "InternalError", "初始化配置失败", http.StatusInternalServerError)
                return
        }</span>

        // 设置自定义配置
        <span class="cov8" title="1">h.metadata.SetSetting(storage.SettingServerHost, req.ServerHost)
        h.metadata.SetSetting(storage.SettingServerPort, req.ServerPort)
        h.metadata.SetSetting(storage.SettingServerRegion, req.ServerRegion)
        h.metadata.SetSetting(storage.SettingStorageDataPath, req.StorageDataPath)

        // 标记为已安装
        if err := h.metadata.SetInstalled(); err != nil </span><span class="cov0" title="0">{
                utils.Error("设置安装状态失败", "error", err)
                utils.WriteErrorResponse(w, "InternalError", "设置安装状态失败", http.StatusInternalServerError)
                return
        }</span>

        // 获取生成的 API Key
        <span class="cov8" title="1">accessKeyID, secretAccessKey := h.metadata.GetAuthConfig()

        // 重新加载配置到全局
        ReloadConfigFromDB(h.metadata)

        // 记录安装审计日志
        h.Audit(r, storage.AuditActionSystemInstall, req.AdminUsername, "", true, map[string]string{
                "server_host": req.ServerHost,
                "server_port": req.ServerPort,
        })

        utils.WriteJSONResponse(w, SetupResponse{
                Success:         true,
                Message:         "安装成功",
                AccessKeyID:     accessKeyID,
                SecretAccessKey: secretAccessKey,
        })</span>
}

// handleResetPasswordCheck 检测密码重置文件是否存在
func (h *Handler) handleResetPasswordCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        // 获取绝对路径
        <span class="cov8" title="1">absPath, _ := filepath.Abs(resetPasswordFile)

        // 检测文件是否存在
        _, err := os.Stat(resetPasswordFile)
        fileExists := err == nil

        utils.WriteJSONResponse(w, ResetPasswordCheckResponse{
                FileExists: fileExists,
                FilePath:   absPath,
                Command:    "touch " + absPath,
        })</span>
}

// handleResetPassword 重置密码
func (h *Handler) handleResetPassword(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        // 检测重置文件是否存在
        <span class="cov8" title="1">if _, err := os.Stat(resetPasswordFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "ResetFileNotFound",
                        "密码重置文件不存在，请先在服务器执行 touch "+resetPasswordFile,
                        http.StatusForbidden)
                return
        }</span>

        <span class="cov8" title="1">var req ResetPasswordRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        // 验证新密码
        <span class="cov8" title="1">if req.NewPassword == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", "新密码不能为空", http.StatusBadRequest)
                return
        }</span>
        // 使用统一的密码复杂度验证
        <span class="cov8" title="1">if err := storage.ValidatePassword(req.NewPassword); err != nil </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidParameter", err.Error(), http.StatusBadRequest)
                return
        }</span>

        // 更新密码
        <span class="cov8" title="1">if err := h.metadata.SetAdminPassword(req.NewPassword); err != nil </span><span class="cov0" title="0">{
                utils.Error("重置密码失败", "error", err)
                utils.WriteErrorResponse(w, "InternalError", "重置密码失败", http.StatusInternalServerError)
                return
        }</span>

        // 删除重置文件
        <span class="cov8" title="1">os.Remove(resetPasswordFile)

        // 清除所有会话（强制重新登录）
        sessionStore.mu.Lock()
        sessionStore.sessions = make(map[string]*Session)
        sessionStore.mu.Unlock()

        // 记录密码重置审计日志
        h.Audit(r, storage.AuditActionPasswordReset, "admin", "", true, nil)

        utils.WriteJSONResponse(w, map[string]interface{}{
                "success":    true,
                "message":    "密码重置成功，请使用新密码登录",
                "reset_time": time.Now().UTC().Format(time.RFC3339),
        })</span>
}

// ReloadConfigFromDB 从数据库重新加载配置到全局变量
func ReloadConfigFromDB(metadata *storage.MetadataStore) <span class="cov8" title="1">{
        config.LoadFromDB(metadata)
        // 重新加载 API Key 缓存
        auth.ReloadAPIKeyCache()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package admin

import (
        "net/http"
        "time"

        "sss/internal/storage"
        "sss/internal/utils"
)

// GCRequest 垃圾回收请求
type GCRequest struct {
        MaxUploadAge int  `json:"max_upload_age"` // 过期上传的最大年龄（小时）
        DryRun       bool `json:"dry_run"`        // 是否仅扫描不清理
}

// IntegrityRequest 完整性检查请求
type IntegrityRequest struct {
        VerifyEtag bool                     `json:"verify_etag"` // 是否验证 ETag
        Limit      int                      `json:"limit"`       // 检查数量限制
        Repair     bool                     `json:"repair"`      // 是否执行修复
        Issues     []storage.IntegrityIssue `json:"issues"`      // 需要修复的问题列表
}

// handleStorageStats 获取存储统计信息
func (h *Handler) handleStorageStats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">stats, err := h.metadata.GetStorageStats()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get storage stats failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 获取磁盘实际使用情况
        <span class="cov8" title="1">diskSize, fileCount, _ := h.filestore.GetDiskUsage()

        response := map[string]interface{}{
                "stats":           stats,
                "disk_usage":      diskSize,
                "disk_file_count": fileCount,
        }

        utils.WriteJSONResponse(w, response)</span>
}

// handleRecentObjects 获取最近上传的对象
func (h *Handler) handleRecentObjects(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">limit := 10
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if l, err := parseInt(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 50 </span><span class="cov8" title="1">{
                        limit = l
                }</span>
        }

        <span class="cov8" title="1">objects, err := h.metadata.GetRecentObjects(limit)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get recent objects failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">result := make([]AdminObjectInfo, 0, len(objects))
        for _, obj := range objects </span><span class="cov0" title="0">{
                result = append(result, AdminObjectInfo{
                        Key:          obj.Bucket + "/" + obj.Key,
                        Size:         obj.Size,
                        LastModified: obj.LastModified.Format(time.RFC3339),
                        ETag:         obj.ETag,
                })
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, result)</span>
}

// parseInt 解析整数
func parseInt(s string) (int, error) <span class="cov8" title="1">{
        var n int
        for _, c := range s </span><span class="cov8" title="1">{
                if c &lt; '0' || c &gt; '9' </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">n = n*10 + int(c-'0')</span>
        }
        <span class="cov8" title="1">return n, nil</span>
}

// handleGC 处理垃圾回收
// GET: 扫描并返回预览（dry run）
// POST: 执行清理
func (h *Handler) handleGC(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.scanGC(w, r)</span>
        case http.MethodPost:<span class="cov8" title="1">
                h.executeGC(w, r)</span>
        default:<span class="cov8" title="1">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}

// scanGC 扫描垃圾（预览模式）
func (h *Handler) scanGC(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // 默认过期时间 24 小时
        maxUploadAge := 24 * time.Hour

        // 从 query 参数获取自定义过期时间
        if ageStr := r.URL.Query().Get("max_upload_age"); ageStr != "" </span><span class="cov8" title="1">{
                if hours, err := parseInt(ageStr); err == nil &amp;&amp; hours &gt; 0 </span><span class="cov8" title="1">{
                        maxUploadAge = time.Duration(hours) * time.Hour
                }</span>
        }

        <span class="cov8" title="1">result, err := storage.RunGC(h.filestore, h.metadata, maxUploadAge, true)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("gc scan failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, result)</span>
}

// executeGC 执行垃圾回收
func (h *Handler) executeGC(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req GCRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                // 使用默认值
                req.MaxUploadAge = 24
                req.DryRun = false
        }</span>

        // 默认过期时间 24 小时
        <span class="cov8" title="1">maxUploadAge := time.Duration(req.MaxUploadAge) * time.Hour
        if maxUploadAge &lt;= 0 </span><span class="cov8" title="1">{
                maxUploadAge = 24 * time.Hour
        }</span>

        <span class="cov8" title="1">result, err := storage.RunGC(h.filestore, h.metadata, maxUploadAge, req.DryRun)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("gc execute failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, result)</span>
}

// handleIntegrity 处理完整性检查
// GET: 扫描并返回问题列表
// POST: 执行修复
func (h *Handler) handleIntegrity(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.checkIntegrity(w, r)</span>
        case http.MethodPost:<span class="cov8" title="1">
                h.repairIntegrity(w, r)</span>
        default:<span class="cov8" title="1">
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")</span>
        }
}

// checkIntegrity 检查数据完整性
func (h *Handler) checkIntegrity(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // 是否验证 ETag（默认不验证，因为计算 MD5 较慢）
        verifyEtag := r.URL.Query().Get("verify_etag") == "true"

        // 检查数量限制（默认 1000）
        limit := 1000
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if l, err := parseInt(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov8" title="1">{
                        limit = l
                }</span>
        }

        <span class="cov8" title="1">result, err := storage.CheckIntegrity(h.filestore, h.metadata, verifyEtag, limit)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("integrity check failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, result)</span>
}

// repairIntegrity 修复完整性问题
func (h *Handler) repairIntegrity(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req IntegrityRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        // 如果没有提供问题列表，先扫描
        <span class="cov8" title="1">if len(req.Issues) == 0 </span><span class="cov8" title="1">{
                scanResult, err := storage.CheckIntegrity(h.filestore, h.metadata, req.VerifyEtag, req.Limit)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("integrity scan for repair failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                        return
                }</span>
                <span class="cov8" title="1">req.Issues = scanResult.Issues</span>
        }

        // 执行修复
        <span class="cov8" title="1">result, err := storage.RepairIntegrity(h.filestore, h.metadata, req.Issues)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("integrity repair failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, result)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "encoding/xml"
        "net/http"
        "strconv"
        "strings"
        "time"

        "sss/internal/config"
        "sss/internal/utils"
)

// ListAllMyBucketsResult ListBuckets 响应
type ListAllMyBucketsResult struct {
        XMLName xml.Name `xml:"ListAllMyBucketsResult"`
        Xmlns   string   `xml:"xmlns,attr"`
        Owner   Owner    `xml:"Owner"`
        Buckets Buckets  `xml:"Buckets"`
}

type Owner struct {
        ID          string `xml:"ID"`
        DisplayName string `xml:"DisplayName"`
}

type Buckets struct {
        Bucket []BucketInfo `xml:"Bucket"`
}

type BucketInfo struct {
        Name         string `xml:"Name"`
        CreationDate string `xml:"CreationDate"`
}

// handleListBuckets 列出所有存储桶
func (s *Server) handleListBuckets(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        buckets, err := s.metadata.ListBuckets()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("list buckets failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/")
                return
        }</span>

        <span class="cov8" title="1">result := ListAllMyBucketsResult{
                Xmlns: "http://s3.amazonaws.com/doc/2006-03-01/",
                Owner: Owner{
                        ID:          config.Global.Auth.AccessKeyID,
                        DisplayName: "sss-user",
                },
                Buckets: Buckets{
                        Bucket: make([]BucketInfo, 0, len(buckets)),
                },
        }

        for _, b := range buckets </span><span class="cov8" title="1">{
                result.Buckets.Bucket = append(result.Buckets.Bucket, BucketInfo{
                        Name:         b.Name,
                        CreationDate: b.CreationDate.UTC().Format(time.RFC3339),
                })
        }</span>

        <span class="cov8" title="1">utils.WriteXML(w, http.StatusOK, result)</span>
}

// handleCreateBucket 创建存储桶
func (s *Server) handleCreateBucket(w http.ResponseWriter, r *http.Request, bucket string) <span class="cov8" title="1">{
        // 直接尝试创建，依赖数据库 PRIMARY KEY 约束处理冲突
        if err := s.metadata.CreateBucket(bucket); err != nil </span><span class="cov8" title="1">{
                // 检查是否是重复键错误（桶已存在）
                if strings.Contains(err.Error(), "UNIQUE constraint failed") ||
                        strings.Contains(err.Error(), "PRIMARY KEY") </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrBucketAlreadyExists, http.StatusConflict, "/"+bucket)
                        return
                }</span>
                <span class="cov0" title="0">utils.Error("create bucket metadata failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                return</span>
        }

        // 创建目录
        <span class="cov8" title="1">if err := s.filestore.CreateBucket(bucket); err != nil </span><span class="cov0" title="0">{
                utils.Error("create bucket directory failed", "error", err)
                s.metadata.DeleteBucket(bucket) // 回滚
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Location", "/"+bucket)
        w.WriteHeader(http.StatusOK)</span>
}

// handleDeleteBucket 删除存储桶
func (s *Server) handleDeleteBucket(w http.ResponseWriter, r *http.Request, bucket string) <span class="cov8" title="1">{
        // 检查是否存在
        existing, err := s.metadata.GetBucket(bucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                return
        }</span>
        <span class="cov8" title="1">if existing == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "/"+bucket)
                return
        }</span>

        // 删除元数据（会检查是否为空）
        <span class="cov8" title="1">if err := s.metadata.DeleteBucket(bucket); err != nil </span><span class="cov8" title="1">{
                if err.Error() == "bucket not empty" </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrBucketNotEmpty, http.StatusConflict, "/"+bucket)
                }</span> else<span class="cov0" title="0"> {
                        utils.Error("delete bucket metadata failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // 删除目录
        <span class="cov8" title="1">if err := s.filestore.DeleteBucket(bucket); err != nil </span><span class="cov0" title="0">{
                utils.Error("delete bucket directory failed", "error", err)
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// handleHeadBucket 检查存储桶是否存在
func (s *Server) handleHeadBucket(w http.ResponseWriter, r *http.Request, bucket string) <span class="cov8" title="1">{
        existing, err := s.metadata.GetBucket(bucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if existing == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("x-amz-bucket-region", config.Global.Server.Region)
        w.WriteHeader(http.StatusOK)</span>
}

// ListBucketResult ListObjects V1 响应
type ListBucketResult struct {
        XMLName        xml.Name       `xml:"ListBucketResult"`
        Xmlns          string         `xml:"xmlns,attr"`
        Name           string         `xml:"Name"`
        Prefix         string         `xml:"Prefix"`
        Marker         string         `xml:"Marker"`
        MaxKeys        int            `xml:"MaxKeys"`
        IsTruncated    bool           `xml:"IsTruncated"`
        Contents       []ObjectInfo   `xml:"Contents"`
        CommonPrefixes []CommonPrefix `xml:"CommonPrefixes,omitempty"`
}

// ListBucketResultV2 ListObjects V2 响应
type ListBucketResultV2 struct {
        XMLName               xml.Name       `xml:"ListBucketResult"`
        Xmlns                 string         `xml:"xmlns,attr"`
        Name                  string         `xml:"Name"`
        Prefix                string         `xml:"Prefix"`
        KeyCount              int            `xml:"KeyCount"`
        MaxKeys               int            `xml:"MaxKeys"`
        IsTruncated           bool           `xml:"IsTruncated"`
        Contents              []ObjectInfo   `xml:"Contents"`
        CommonPrefixes        []CommonPrefix `xml:"CommonPrefixes,omitempty"`
        ContinuationToken     string         `xml:"ContinuationToken,omitempty"`
        NextContinuationToken string         `xml:"NextContinuationToken,omitempty"`
        StartAfter            string         `xml:"StartAfter,omitempty"`
}

type ObjectInfo struct {
        Key          string `xml:"Key"`
        LastModified string `xml:"LastModified"`
        ETag         string `xml:"ETag"`
        Size         int64  `xml:"Size"`
        StorageClass string `xml:"StorageClass"`
}

type CommonPrefix struct {
        Prefix string `xml:"Prefix"`
}

// handleListObjects 列出存储桶中的对象
func (s *Server) handleListObjects(w http.ResponseWriter, r *http.Request, bucket string) <span class="cov8" title="1">{
        // 检查存储桶是否存在
        existing, err := s.metadata.GetBucket(bucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                return
        }</span>
        <span class="cov8" title="1">if existing == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "/"+bucket)
                return
        }</span>

        <span class="cov8" title="1">query := r.URL.Query()
        prefix := query.Get("prefix")
        delimiter := query.Get("delimiter")
        maxKeysStr := query.Get("max-keys")
        maxKeys := 1000
        if maxKeysStr != "" </span><span class="cov8" title="1">{
                if n, err := strconv.Atoi(maxKeysStr); err == nil &amp;&amp; n &gt; 0 </span><span class="cov8" title="1">{
                        maxKeys = n
                }</span>
        }

        // 判断是 V1 还是 V2
        <span class="cov8" title="1">if query.Get("list-type") == "2" </span><span class="cov8" title="1">{
                // V2
                continuationToken := query.Get("continuation-token")
                startAfter := query.Get("start-after")
                marker := continuationToken
                if marker == "" </span><span class="cov8" title="1">{
                        marker = startAfter
                }</span>

                <span class="cov8" title="1">result, err := s.metadata.ListObjects(bucket, prefix, marker, delimiter, maxKeys)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("list objects failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                        return
                }</span>

                <span class="cov8" title="1">response := ListBucketResultV2{
                        Xmlns:             "http://s3.amazonaws.com/doc/2006-03-01/",
                        Name:              bucket,
                        Prefix:            prefix,
                        KeyCount:          result.KeyCount,
                        MaxKeys:           maxKeys,
                        IsTruncated:       result.IsTruncated,
                        ContinuationToken: continuationToken,
                        StartAfter:        startAfter,
                }

                if result.IsTruncated </span><span class="cov0" title="0">{
                        response.NextContinuationToken = result.NextMarker
                }</span>

                <span class="cov8" title="1">for _, obj := range result.Contents </span><span class="cov0" title="0">{
                        response.Contents = append(response.Contents, ObjectInfo{
                                Key:          obj.Key,
                                LastModified: obj.LastModified.UTC().Format(time.RFC3339),
                                ETag:         `"` + obj.ETag + `"`,
                                Size:         obj.Size,
                                StorageClass: "STANDARD",
                        })
                }</span>

                <span class="cov8" title="1">for _, p := range result.CommonPrefixes </span><span class="cov0" title="0">{
                        response.CommonPrefixes = append(response.CommonPrefixes, CommonPrefix{Prefix: p})
                }</span>

                <span class="cov8" title="1">utils.WriteXML(w, http.StatusOK, response)</span>
        } else<span class="cov8" title="1"> {
                // V1
                marker := query.Get("marker")

                result, err := s.metadata.ListObjects(bucket, prefix, marker, delimiter, maxKeys)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("list objects failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                        return
                }</span>

                <span class="cov8" title="1">response := ListBucketResult{
                        Xmlns:       "http://s3.amazonaws.com/doc/2006-03-01/",
                        Name:        bucket,
                        Prefix:      prefix,
                        Marker:      marker,
                        MaxKeys:     maxKeys,
                        IsTruncated: result.IsTruncated,
                }

                for _, obj := range result.Contents </span><span class="cov8" title="1">{
                        response.Contents = append(response.Contents, ObjectInfo{
                                Key:          obj.Key,
                                LastModified: obj.LastModified.UTC().Format(time.RFC3339),
                                ETag:         `"` + obj.ETag + `"`,
                                Size:         obj.Size,
                                StorageClass: "STANDARD",
                        })
                }</span>

                <span class="cov8" title="1">for _, p := range result.CommonPrefixes </span><span class="cov0" title="0">{
                        response.CommonPrefixes = append(response.CommonPrefixes, CommonPrefix{Prefix: p})
                }</span>

                <span class="cov8" title="1">utils.WriteXML(w, http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">//go:build !embed
// +build !embed

package api

import (
        "os"
)

func init() <span class="cov8" title="1">{
        // 开发模式：从文件系统读取静态文件
        staticFS = os.DirFS("./data/static")
        useEmbed = false
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "context"
        "net/http"
        "strings"
        "time"

        "sss/internal/admin"
        "sss/internal/auth"
        "sss/internal/config"
        "sss/internal/storage"
        "sss/internal/utils"
)

// 上下文键类型
type contextKey string

const (
        // ContextKeyAccessKeyID 存储验证通过的 Access Key ID
        ContextKeyAccessKeyID contextKey = "accessKeyID"
)

// Server S3服务器
type Server struct {
        metadata     *storage.MetadataStore
        filestore    *storage.FileStore
        adminHandler *admin.Handler
        mux          *http.ServeMux
}

// NewServer 创建服务器
func NewServer(metadata *storage.MetadataStore, filestore *storage.FileStore) *Server <span class="cov8" title="1">{
        s := &amp;Server{
                metadata:     metadata,
                filestore:    filestore,
                adminHandler: admin.NewHandler(metadata, filestore),
                mux:          http.NewServeMux(),
        }
        s.setupRoutes()
        return s
}</span>

// setupRoutes 设置路由
func (s *Server) setupRoutes() <span class="cov8" title="1">{
        s.mux.HandleFunc("/", s.handleRequest)
        // Web管理界面API端点
        s.mux.HandleFunc("/api/presign", s.handlePresign)
        s.mux.HandleFunc("/api/bucket/", s.handleBucketAPI)
}</span>

// ServeHTTP 实现 http.Handler
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // 添加通用头部
        w.Header().Set("Server", "SSS")
        w.Header().Set("x-amz-request-id", utils.GenerateRequestID())

        // CORS 支持（使用可配置的来源）
        corsOrigin := "*"
        if cfg := config.Global; cfg != nil &amp;&amp; cfg.Security.CORSOrigin != "" </span><span class="cov8" title="1">{
                corsOrigin = cfg.Security.CORSOrigin
        }</span>
        <span class="cov8" title="1">w.Header().Set("Access-Control-Allow-Origin", corsOrigin)
        w.Header().Set("Access-Control-Allow-Methods", "GET, PUT, POST, DELETE, HEAD, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "*")
        w.Header().Set("Access-Control-Expose-Headers", "ETag, x-amz-request-id, x-amz-id-2")

        if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">utils.Info("request", "method", r.Method, "path", r.URL.Path, "query", r.URL.RawQuery)

        s.mux.ServeHTTP(w, r)</span>
}

// isRootStaticFile 检查是否是根目录静态文件（仅限根目录下的文件，不包括子路径）
// 修复安全漏洞：之前只检查后缀，导致 /bucket/file.txt 被误判为静态文件并绕过认证
func isRootStaticFile(path string) bool <span class="cov8" title="1">{
        // 确保是根目录文件（只有一个 /，即文件在根目录下）
        // 例如：/robots.txt 匹配，但 /ccdd/test.txt 不匹配
        if !strings.HasPrefix(path, "/") || strings.Count(path, "/") &gt; 1 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return strings.HasSuffix(path, ".svg") ||
                strings.HasSuffix(path, ".ico") ||
                strings.HasSuffix(path, ".png") ||
                strings.HasSuffix(path, ".txt") ||
                strings.HasSuffix(path, ".webmanifest")</span>
}

// handleRequest 处理请求
func (s *Server) handleRequest(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // 1. 检查是否是静态文件请求
        // 对于根路径，优先检查是否有 S3 签名头，有则处理为 API 请求
        if r.URL.Path == "/" </span><span class="cov8" title="1">{
                // 优先检查 Authorization 头或预签名参数，这是 S3 API 请求的标志
                hasS3Auth := r.Header.Get("Authorization") != "" || r.URL.Query().Get("X-Amz-Signature") != ""
                if !hasS3Auth </span><span class="cov8" title="1">{
                        accept := r.Header.Get("Accept")
                        userAgent := r.Header.Get("User-Agent")
                        // 如果 Accept 包含 text/html 或者 User-Agent 包含浏览器关键字
                        if (accept != "" &amp;&amp; strings.Contains(accept, "text/html")) ||
                                (userAgent != "" &amp;&amp; (strings.Contains(userAgent, "Mozilla") || strings.Contains(userAgent, "Chrome") || strings.Contains(userAgent, "Safari") || strings.Contains(userAgent, "Firefox"))) </span><span class="cov8" title="1">{
                                // 浏览器访问，返回 HTML
                                s.serveStatic(w, r)
                                return
                        }</span>
                }
                // 否则继续处理 S3 API
        } else<span class="cov8" title="1"> if strings.HasPrefix(r.URL.Path, "/assets/") </span><span class="cov8" title="1">{
                s.serveStatic(w, r)
                return
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(r.URL.Path, "/admin") </span><span class="cov8" title="1">{
                // 管理界面 SPA 路由，返回 index.html 让前端路由处理
                s.serveStatic(w, r)
                return
        }</span> else<span class="cov8" title="1"> if isRootStaticFile(r.URL.Path) </span><span class="cov0" title="0">{
                // 处理根目录静态文件（favicon.svg, robots.txt 等）
                s.serveStatic(w, r)
                return
        }</span>

        // 2. 检查是否是API管理路径
        <span class="cov8" title="1">if strings.HasPrefix(r.URL.Path, "/api/") </span><span class="cov8" title="1">{
                // 健康检查端点 - 不需要认证
                if r.URL.Path == "/api/health" </span><span class="cov8" title="1">{
                        s.handleHealth(w, r)
                        return
                }</span>
                // 安装相关 API 和管理员 API - 委托给 adminHandler
                <span class="cov8" title="1">if strings.HasPrefix(r.URL.Path, "/api/setup") || strings.HasPrefix(r.URL.Path, "/api/admin/") </span><span class="cov8" title="1">{
                        s.adminHandler.ServeHTTP(w, r)
                        return
                }</span>
                // 其他 API 路径需要 S3 认证
                <span class="cov8" title="1">newReq, ok := s.checkAuth(r, w)
                if !ok </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov0" title="0">r = newReq
                // 交给API处理器
                if strings.HasPrefix(r.URL.Path, "/api/presign") </span><span class="cov0" title="0">{
                        s.handlePresign(w, r)
                        return
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(r.URL.Path, "/api/bucket/") </span><span class="cov0" title="0">{
                        s.handleBucketAPI(w, r)
                        return
                }</span>
        }

        // 3. S3 API 处理
        // 解析路径获取bucket
        <span class="cov8" title="1">path := strings.TrimPrefix(r.URL.Path, "/")
        parts := strings.SplitN(path, "/", 2)
        var bucket string
        if len(parts) &gt;= 1 &amp;&amp; parts[0] != "" </span><span class="cov8" title="1">{
                bucket = parts[0]
        }</span>

        // 4. 认证检查
        <span class="cov8" title="1">var isPublicAccess bool
        if bucket != "" </span><span class="cov8" title="1">{
                // 检查桶是否为公有（只对GET/HEAD请求）
                if r.Method == http.MethodGet || r.Method == http.MethodHead </span><span class="cov8" title="1">{
                        if bucketInfo, err := s.metadata.GetBucket(bucket); err == nil &amp;&amp; bucketInfo != nil &amp;&amp; bucketInfo.IsPublic </span><span class="cov8" title="1">{
                                // 公有桶的GET/HEAD请求跳过认证
                                utils.Debug("public bucket access", "bucket", bucket, "method", r.Method)
                                isPublicAccess = true
                        }</span>
                }

                <span class="cov8" title="1">if !isPublicAccess </span><span class="cov8" title="1">{
                        // 需要认证
                        newReq, ok := s.checkAuth(r, w)
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov0" title="0">r = newReq

                        // 检查桶权限（创建/删除桶只有旧配置的管理员 Key 能操作）
                        needWrite := r.Method != http.MethodGet &amp;&amp; r.Method != http.MethodHead
                        if !s.checkBucketPermission(r, w, bucket, needWrite) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // ListBuckets需要认证
                newReq, ok := s.checkAuth(r, w)
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">r = newReq</span>
        }

        // 重新解析路径（之前的bucket已经获取了）
        <span class="cov8" title="1">key := ""
        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                key = parts[1]
        }</span>

        // 检查是否是多段上传相关操作
        <span class="cov8" title="1">query := r.URL.Query()

        // 路由到具体处理器
        switch </span>{
        // ListBuckets - GET /
        case r.Method == "GET" &amp;&amp; bucket == "":<span class="cov0" title="0">
                s.handleListBuckets(w, r)</span>

        // CreateBucket - PUT /{bucket}
        case r.Method == "PUT" &amp;&amp; bucket != "" &amp;&amp; key == "":<span class="cov0" title="0">
                s.handleCreateBucket(w, r, bucket)</span>

        // DeleteBucket - DELETE /{bucket}
        case r.Method == "DELETE" &amp;&amp; bucket != "" &amp;&amp; key == "":<span class="cov0" title="0">
                s.handleDeleteBucket(w, r, bucket)</span>

        // HeadBucket - HEAD /{bucket}
        case r.Method == "HEAD" &amp;&amp; bucket != "" &amp;&amp; key == "":<span class="cov0" title="0">
                s.handleHeadBucket(w, r, bucket)</span>

        // ListObjects - GET /{bucket}
        case r.Method == "GET" &amp;&amp; bucket != "" &amp;&amp; key == "":<span class="cov8" title="1">
                s.handleListObjects(w, r, bucket)</span>

        // Multipart Upload 操作
        case query.Has("uploads"):<span class="cov0" title="0">
                if r.Method == "POST" &amp;&amp; key != "" </span><span class="cov0" title="0">{
                        // InitiateMultipartUpload
                        s.handleInitiateMultipartUpload(w, r, bucket, key)
                }</span> else<span class="cov0" title="0"> if r.Method == "GET" </span><span class="cov0" title="0">{
                        // ListMultipartUploads (暂未实现)
                        w.WriteHeader(http.StatusNotImplemented)
                }</span>

        case query.Get("uploadId") != "":<span class="cov0" title="0">
                uploadID := query.Get("uploadId")
                switch r.Method </span>{
                case "PUT":<span class="cov0" title="0">
                        // UploadPart
                        s.handleUploadPart(w, r, bucket, key, uploadID)</span>
                case "POST":<span class="cov0" title="0">
                        // CompleteMultipartUpload
                        s.handleCompleteMultipartUpload(w, r, bucket, key, uploadID)</span>
                case "DELETE":<span class="cov0" title="0">
                        // AbortMultipartUpload
                        s.handleAbortMultipartUpload(w, r, bucket, key, uploadID)</span>
                case "GET":<span class="cov0" title="0">
                        // ListParts
                        s.handleListParts(w, r, bucket, key, uploadID)</span>
                }

        // GetObject - GET /{bucket}/{key}
        case r.Method == "GET" &amp;&amp; key != "":<span class="cov8" title="1">
                s.handleGetObject(w, r, bucket, key)</span>

        // PutObject or CopyObject - PUT /{bucket}/{key}
        case r.Method == "PUT" &amp;&amp; key != "":<span class="cov0" title="0">
                // 检查是否是复制操作（有 x-amz-copy-source 头）
                if r.Header.Get("x-amz-copy-source") != "" </span><span class="cov0" title="0">{
                        s.handleCopyObject(w, r, bucket, key)
                }</span> else<span class="cov0" title="0"> {
                        s.handlePutObject(w, r, bucket, key)
                }</span>

        // DeleteObject - DELETE /{bucket}/{key}
        case r.Method == "DELETE" &amp;&amp; key != "":<span class="cov0" title="0">
                s.handleDeleteObject(w, r, bucket, key)</span>

        // HeadObject - HEAD /{bucket}/{key}
        case r.Method == "HEAD" &amp;&amp; key != "":<span class="cov8" title="1">
                s.handleHeadObject(w, r, bucket, key)</span>

        default:<span class="cov0" title="0">
                w.WriteHeader(http.StatusMethodNotAllowed)</span>
        }
}

// PresignRequest 预签名请求结构
type PresignRequest struct {
        Method         string `json:"method"`
        Bucket         string `json:"bucket"`
        Key            string `json:"key"`
        ExpiresMinutes int    `json:"expiresMinutes"`
        MaxSizeMB      int64  `json:"maxSizeMB"`
        ContentType    string `json:"contentType"`
}

// PresignResponse 预签名响应结构
type PresignResponse struct {
        URL     string `json:"url"`
        Method  string `json:"method"`
        Expires int    `json:"expires"`
}

// handlePresign 处理预签名URL生成请求
func (s *Server) handlePresign(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        // 验证请求体大小限制（防止大请求攻击）
        <span class="cov8" title="1">r.Body = http.MaxBytesReader(w, r.Body, 1024*1024) // 最大1MB

        var req PresignRequest
        if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                return
        }</span>

        // 验证请求参数
        <span class="cov8" title="1">if req.Bucket == "" || req.Key == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "MissingRequiredParameter", "bucket and key are required", http.StatusBadRequest)
                return
        }</span>

        // 验证bucket和key的安全性
        <span class="cov8" title="1">if strings.Contains(req.Bucket, "..") || strings.ContainsAny(req.Bucket, "/\\") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidBucketName", "Invalid bucket name", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if strings.Contains(req.Key, "..") || strings.HasPrefix(req.Key, "/") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidKey", "Invalid object key", http.StatusBadRequest)
                return
        }</span>

        // 检查存储桶是否存在
        <span class="cov8" title="1">bucket, err := s.metadata.GetBucket(req.Bucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if bucket == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "")
                return
        }</span>

        // 设置默认值
        <span class="cov8" title="1">if req.Method == "" </span><span class="cov8" title="1">{
                req.Method = "PUT"
        }</span>
        <span class="cov8" title="1">if req.ExpiresMinutes == 0 </span><span class="cov8" title="1">{
                req.ExpiresMinutes = 60 // 默认1小时
        }</span>
        <span class="cov8" title="1">if req.ExpiresMinutes &gt; 7*24*60 </span><span class="cov8" title="1">{ // 最大7天
                req.ExpiresMinutes = 7 * 24 * 60
        }</span>

        // 构建预签名选项
        <span class="cov8" title="1">opts := &amp;auth.PresignOptions{
                Expires: time.Duration(req.ExpiresMinutes) * time.Minute,
        }

        // 设置大小限制（MB转字节）
        if req.MaxSizeMB &gt; 0 </span><span class="cov8" title="1">{
                opts.MaxContentLength = req.MaxSizeMB * 1024 * 1024
        }</span>

        // 设置内容类型
        <span class="cov8" title="1">if req.ContentType != "" </span><span class="cov8" title="1">{
                opts.ContentType = req.ContentType
        }</span>

        // 生成预签名URL
        <span class="cov8" title="1">url := auth.GeneratePresignedURLWithOptions(req.Method, req.Bucket, req.Key, opts)

        // 构建响应
        resp := PresignResponse{
                URL:     url,
                Method:  req.Method,
                Expires: req.ExpiresMinutes * 60, // 转换为秒
        }

        utils.WriteJSONResponse(w, resp)</span>
}

// BucketPublicRequest 设置桶公有/私有请求
type BucketPublicRequest struct {
        IsPublic bool `json:"is_public"`
}

// handleBucketAPI 处理桶管理API
func (s *Server) handleBucketAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // 解析路径 /api/bucket/{bucket-name}/{action}
        pathParts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
        if len(pathParts) &lt; 4 || pathParts[2] == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidPath", "Invalid API path", http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">bucketName := pathParts[2]
        action := pathParts[3]

        switch action </span>{
        case "public":<span class="cov0" title="0">
                s.handleBucketPublicAPI(w, r, bucketName)</span>
        case "search":<span class="cov0" title="0">
                s.handleBucketSearchAPI(w, r, bucketName)</span>
        case "head":<span class="cov0" title="0">
                s.handleBucketHeadObjectAPI(w, r, bucketName)</span>
        default:<span class="cov8" title="1">
                utils.WriteErrorResponse(w, "InvalidPath", "Invalid API action", http.StatusNotFound)</span>
        }
}

// handleBucketPublicAPI 处理桶公有/私有状态 API
func (s *Server) handleBucketPublicAPI(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if r.Method != http.MethodPut &amp;&amp; r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        <span class="cov8" title="1">if r.Method == http.MethodPut </span><span class="cov8" title="1">{
                // 设置桶的公有/私有状态
                var req BucketPublicRequest
                if err := utils.ParseJSONBody(r, &amp;req); err != nil </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrMalformedJSON, http.StatusBadRequest, "")
                        return
                }</span>

                // 检查桶是否存在
                <span class="cov8" title="1">bucket, err := s.metadata.GetBucket(bucketName)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("check bucket failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                        return
                }</span>
                <span class="cov8" title="1">if bucket == nil </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "")
                        return
                }</span>

                // 更新桶状态
                <span class="cov8" title="1">if err := s.metadata.UpdateBucketPublic(bucketName, req.IsPublic); err != nil </span><span class="cov0" title="0">{
                        utils.Error("update bucket public status failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                        return
                }</span>

                <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]bool{"is_public": req.IsPublic})</span>
        } else<span class="cov8" title="1"> {
                // GET 获取桶的公有/私有状态
                bucket, err := s.metadata.GetBucket(bucketName)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("check bucket failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                        return
                }</span>
                <span class="cov8" title="1">if bucket == nil </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "")
                        return
                }</span>

                <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]bool{"is_public": bucket.IsPublic})</span>
        }
}

// handleBucketSearchAPI 处理对象模糊搜索 API
// GET /api/bucket/{bucket}/search?q={keyword}
func (s *Server) handleBucketSearchAPI(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        // 获取搜索关键字
        <span class="cov8" title="1">keyword := r.URL.Query().Get("q")
        if keyword == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "MissingParameter", "Missing 'q' parameter", http.StatusBadRequest)
                return
        }</span>

        // 检查桶是否存在
        <span class="cov8" title="1">bucket, err := s.metadata.GetBucket(bucketName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if bucket == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "")
                return
        }</span>

        // 执行搜索
        <span class="cov8" title="1">objects, err := s.metadata.SearchObjects(bucketName, keyword, 100)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("search objects failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        // 返回搜索结果
        <span class="cov8" title="1">type SearchResult struct {
                Key          string `json:"Key"`
                Size         int64  `json:"Size"`
                LastModified string `json:"LastModified"`
                ETag         string `json:"ETag"`
        }
        results := make([]SearchResult, 0, len(objects))
        for _, obj := range objects </span><span class="cov8" title="1">{
                results = append(results, SearchResult{
                        Key:          obj.Key,
                        Size:         obj.Size,
                        LastModified: obj.LastModified.Format(time.RFC3339),
                        ETag:         obj.ETag,
                })
        }</span>

        <span class="cov8" title="1">utils.WriteJSONResponse(w, map[string]interface{}{
                "keyword": keyword,
                "count":   len(results),
                "objects": results,
        })</span>
}

// handleBucketHeadObjectAPI 检查对象是否存在
// GET /api/bucket/{bucket}/head?key={key}
func (s *Server) handleBucketHeadObjectAPI(w http.ResponseWriter, r *http.Request, bucketName string) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrMethodNotAllowed, http.StatusMethodNotAllowed, "")
                return
        }</span>

        // 获取对象 key
        <span class="cov8" title="1">key := r.URL.Query().Get("key")
        if key == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "MissingParameter", "Missing 'key' parameter", http.StatusBadRequest)
                return
        }</span>

        // 检查桶是否存在
        <span class="cov8" title="1">bucket, err := s.metadata.GetBucket(bucketName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>
        <span class="cov8" title="1">if bucket == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "")
                return
        }</span>

        // 检查对象是否存在
        <span class="cov8" title="1">obj, err := s.metadata.GetObject(bucketName, key)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check object failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "")
                return
        }</span>

        <span class="cov8" title="1">if obj == nil </span><span class="cov8" title="1">{
                utils.WriteJSONResponse(w, map[string]interface{}{
                        "exists": false,
                        "key":    key,
                })
        }</span> else<span class="cov8" title="1"> {
                utils.WriteJSONResponse(w, map[string]interface{}{
                        "exists":       true,
                        "key":          key,
                        "size":         obj.Size,
                        "lastModified": obj.LastModified.Format(time.RFC3339),
                        "etag":         obj.ETag,
                })
        }</span>
}

// checkAuth 检查认证，返回新的带有 accessKeyID 上下文的 request
func (s *Server) checkAuth(r *http.Request, w http.ResponseWriter) (*http.Request, bool) <span class="cov8" title="1">{
        hasSignature := r.URL.Query().Get("X-Amz-Signature") != ""
        hasAuthHeader := r.Header.Get("Authorization") != ""

        // 如果没有任何认证信息，拒绝访问
        if !hasSignature &amp;&amp; !hasAuthHeader </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrAccessDenied, http.StatusForbidden, r.URL.Path)
                return nil, false
        }</span>

        // 验证认证信息并获取 Access Key ID
        <span class="cov8" title="1">accessKeyID, ok := auth.VerifyRequestAndGetAccessKey(r)
        if !ok </span><span class="cov8" title="1">{
                if hasAuthHeader </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrSignatureDoesNotMatch, http.StatusForbidden, r.URL.Path)
                }</span> else<span class="cov8" title="1"> {
                        utils.WriteError(w, utils.ErrAccessDenied, http.StatusForbidden, r.URL.Path)
                }</span>
                <span class="cov8" title="1">return nil, false</span>
        }

        // 将 accessKeyID 存入请求上下文
        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), ContextKeyAccessKeyID, accessKeyID)
        return r.WithContext(ctx), true</span>
}

// checkBucketPermission 检查桶访问权限
func (s *Server) checkBucketPermission(r *http.Request, w http.ResponseWriter, bucket string, needWrite bool) bool <span class="cov8" title="1">{
        accessKeyID, _ := r.Context().Value(ContextKeyAccessKeyID).(string)
        if accessKeyID == "" </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrAccessDenied, http.StatusForbidden, r.URL.Path)
                return false
        }</span>

        <span class="cov0" title="0">if !auth.CheckBucketPermission(accessKeyID, bucket, needWrite) </span><span class="cov0" title="0">{
                utils.WriteError(w, utils.ErrAccessDenied, http.StatusForbidden, r.URL.Path)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// handleHealth 健康检查端点 - 不需要认证
func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        utils.WriteJSONResponse(w, map[string]interface{}{
                "status":  "ok",
                "version": "1.1.0",
        })
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package api

import (
        "encoding/xml"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "time"

        "sss/internal/storage"
        "sss/internal/utils"
)

// InitiateMultipartUploadResult 初始化多段上传响应
type InitiateMultipartUploadResult struct {
        XMLName  xml.Name `xml:"InitiateMultipartUploadResult"`
        Xmlns    string   `xml:"xmlns,attr"`
        Bucket   string   `xml:"Bucket"`
        Key      string   `xml:"Key"`
        UploadId string   `xml:"UploadId"`
}

// CompleteMultipartUploadResult 完成多段上传响应
type CompleteMultipartUploadResult struct {
        XMLName  xml.Name `xml:"CompleteMultipartUploadResult"`
        Xmlns    string   `xml:"xmlns,attr"`
        Location string   `xml:"Location"`
        Bucket   string   `xml:"Bucket"`
        Key      string   `xml:"Key"`
        ETag     string   `xml:"ETag"`
}

// CompleteMultipartUploadRequest 完成多段上传请求
type CompleteMultipartUploadRequest struct {
        XMLName xml.Name     `xml:"CompleteMultipartUpload"`
        Parts   []PartUpload `xml:"Part"`
}

type PartUpload struct {
        PartNumber int    `xml:"PartNumber"`
        ETag       string `xml:"ETag"`
}

// ListPartsResult 列出分片响应
type ListPartsResult struct {
        XMLName              xml.Name   `xml:"ListPartsResult"`
        Xmlns                string     `xml:"xmlns,attr"`
        Bucket               string     `xml:"Bucket"`
        Key                  string     `xml:"Key"`
        UploadId             string     `xml:"UploadId"`
        PartNumberMarker     int        `xml:"PartNumberMarker"`
        NextPartNumberMarker int        `xml:"NextPartNumberMarker"`
        MaxParts             int        `xml:"MaxParts"`
        IsTruncated          bool       `xml:"IsTruncated"`
        Parts                []PartInfo `xml:"Part"`
}

type PartInfo struct {
        PartNumber   int    `xml:"PartNumber"`
        LastModified string `xml:"LastModified"`
        ETag         string `xml:"ETag"`
        Size         int64  `xml:"Size"`
}

// handleInitiateMultipartUpload 初始化多段上传
func (s *Server) handleInitiateMultipartUpload(w http.ResponseWriter, r *http.Request, bucket, key string) <span class="cov8" title="1">{
        // 检查存储桶
        b, err := s.metadata.GetBucket(bucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                return
        }</span>
        <span class="cov8" title="1">if b == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "/"+bucket)
                return
        }</span>

        // 生成 UploadID
        <span class="cov8" title="1">uploadID := utils.GenerateID(32)

        // 获取 Content-Type
        contentType := r.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov8" title="1">{
                contentType = "application/octet-stream"
        }</span>

        // 创建多段上传记录
        <span class="cov8" title="1">upload := &amp;storage.MultipartUpload{
                UploadID:    uploadID,
                Bucket:      bucket,
                Key:         key,
                Initiated:   time.Now().UTC(),
                ContentType: contentType,
        }

        if err := s.metadata.CreateMultipartUpload(upload); err != nil </span><span class="cov0" title="0">{
                utils.Error("create multipart upload failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        <span class="cov8" title="1">result := InitiateMultipartUploadResult{
                Xmlns:    "http://s3.amazonaws.com/doc/2006-03-01/",
                Bucket:   bucket,
                Key:      key,
                UploadId: uploadID,
        }

        utils.WriteXML(w, http.StatusOK, result)</span>
}

// handleUploadPart 上传分片
func (s *Server) handleUploadPart(w http.ResponseWriter, r *http.Request, bucket, key, uploadID string) <span class="cov8" title="1">{
        // 获取分片号
        partNumberStr := r.URL.Query().Get("partNumber")
        partNumber, err := strconv.Atoi(partNumberStr)
        if err != nil || partNumber &lt; 1 || partNumber &gt; 10000 </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrInvalidArgument, http.StatusBadRequest, "/"+bucket+"/"+key)
                return
        }</span>

        // 检查多段上传是否存在
        <span class="cov8" title="1">upload, err := s.metadata.GetMultipartUpload(uploadID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get multipart upload failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>
        <span class="cov8" title="1">if upload == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchUpload, http.StatusNotFound, "/"+bucket+"/"+key)
                return
        }</span>

        // 存储分片
        <span class="cov8" title="1">etag, size, err := s.filestore.PutPart(uploadID, partNumber, r.Body)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("store part failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        // 保存分片元数据
        <span class="cov8" title="1">part := &amp;storage.Part{
                UploadID:   uploadID,
                PartNumber: partNumber,
                Size:       size,
                ETag:       etag,
                ModifiedAt: time.Now().UTC(),
        }

        if err := s.metadata.PutPart(part); err != nil </span><span class="cov0" title="0">{
                utils.Error("save part metadata failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("ETag", `"`+etag+`"`)
        w.WriteHeader(http.StatusOK)</span>
}

// handleCompleteMultipartUpload 完成多段上传
func (s *Server) handleCompleteMultipartUpload(w http.ResponseWriter, r *http.Request, bucket, key, uploadID string) <span class="cov8" title="1">{
        // 检查多段上传是否存在
        upload, err := s.metadata.GetMultipartUpload(uploadID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get multipart upload failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>
        <span class="cov8" title="1">if upload == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchUpload, http.StatusNotFound, "/"+bucket+"/"+key)
                return
        }</span>

        // 限制请求体大小（防止大请求攻击）
        <span class="cov8" title="1">r.Body = http.MaxBytesReader(w, r.Body, 10*1024*1024) // 最大10MB

        // 解析请求体
        var completeReq CompleteMultipartUploadRequest
        decoder := xml.NewDecoder(r.Body)
        decoder.CharsetReader = nil // 使用默认字符集处理
        if err := decoder.Decode(&amp;completeReq); err != nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrInvalidArgument, http.StatusBadRequest, "/"+bucket+"/"+key)
                return
        }</span>

        // 获取已上传的分片
        <span class="cov8" title="1">dbParts, err := s.metadata.ListParts(uploadID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("list parts failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        // 创建分片映射
        <span class="cov8" title="1">partMap := make(map[int]storage.Part)
        for _, p := range dbParts </span><span class="cov8" title="1">{
                partMap[p.PartNumber] = p
        }</span>

        // 验证请求的分片
        <span class="cov8" title="1">var partNumbers []int
        for _, reqPart := range completeReq.Parts </span><span class="cov8" title="1">{
                dbPart, ok := partMap[reqPart.PartNumber]
                if !ok </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrInvalidPart, http.StatusBadRequest, "/"+bucket+"/"+key)
                        return
                }</span>
                // 验证 ETag（去掉引号）
                <span class="cov8" title="1">reqETag := strings.Trim(reqPart.ETag, `"`)
                if reqETag != dbPart.ETag </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrInvalidPart, http.StatusBadRequest, "/"+bucket+"/"+key)
                        return
                }</span>
                <span class="cov8" title="1">partNumbers = append(partNumbers, reqPart.PartNumber)</span>
        }

        // 按分片号排序
        <span class="cov8" title="1">sort.Ints(partNumbers)

        // 合并分片
        etag, totalSize, err := s.filestore.MergeParts(bucket, key, uploadID, partNumbers)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("merge parts failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        // 保存对象元数据
        <span class="cov8" title="1">obj := &amp;storage.Object{
                Key:          key,
                Bucket:       bucket,
                Size:         totalSize,
                ETag:         etag,
                ContentType:  upload.ContentType,
                LastModified: time.Now().UTC(),
                StoragePath:  s.filestore.GetStoragePath(bucket, key),
        }

        if err := s.metadata.PutObject(obj); err != nil </span><span class="cov0" title="0">{
                utils.Error("save object metadata failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        // 清理多段上传记录
        <span class="cov8" title="1">s.metadata.DeleteParts(uploadID)
        s.metadata.DeleteMultipartUpload(uploadID)

        result := CompleteMultipartUploadResult{
                Xmlns:    "http://s3.amazonaws.com/doc/2006-03-01/",
                Location: "/" + bucket + "/" + key,
                Bucket:   bucket,
                Key:      key,
                ETag:     `"` + etag + `"`,
        }

        utils.WriteXML(w, http.StatusOK, result)</span>
}

// handleAbortMultipartUpload 取消多段上传
func (s *Server) handleAbortMultipartUpload(w http.ResponseWriter, r *http.Request, bucket, key, uploadID string) <span class="cov8" title="1">{
        // 检查多段上传是否存在
        upload, err := s.metadata.GetMultipartUpload(uploadID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get multipart upload failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>
        <span class="cov8" title="1">if upload == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchUpload, http.StatusNotFound, "/"+bucket+"/"+key)
                return
        }</span>

        // 清理分片文件
        <span class="cov8" title="1">if err := s.filestore.AbortMultipartUpload(uploadID); err != nil </span><span class="cov0" title="0">{
                utils.Warn("abort multipart upload files failed", "error", err)
        }</span>

        // 清理元数据
        <span class="cov8" title="1">s.metadata.DeleteParts(uploadID)
        s.metadata.DeleteMultipartUpload(uploadID)

        w.WriteHeader(http.StatusNoContent)</span>
}

// handleListParts 列出已上传的分片
func (s *Server) handleListParts(w http.ResponseWriter, r *http.Request, bucket, key, uploadID string) <span class="cov8" title="1">{
        // 检查多段上传是否存在
        upload, err := s.metadata.GetMultipartUpload(uploadID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get multipart upload failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>
        <span class="cov8" title="1">if upload == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchUpload, http.StatusNotFound, "/"+bucket+"/"+key)
                return
        }</span>

        // 获取分片列表
        <span class="cov8" title="1">parts, err := s.metadata.ListParts(uploadID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("list parts failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        <span class="cov8" title="1">result := ListPartsResult{
                Xmlns:    "http://s3.amazonaws.com/doc/2006-03-01/",
                Bucket:   bucket,
                Key:      key,
                UploadId: uploadID,
                MaxParts: 1000,
        }

        for _, p := range parts </span><span class="cov8" title="1">{
                result.Parts = append(result.Parts, PartInfo{
                        PartNumber:   p.PartNumber,
                        LastModified: p.ModifiedAt.UTC().Format(time.RFC3339),
                        ETag:         `"` + p.ETag + `"`,
                        Size:         p.Size,
                })
        }</span>

        <span class="cov8" title="1">if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                result.NextPartNumberMarker = parts[len(parts)-1].PartNumber
        }</span>

        <span class="cov8" title="1">utils.WriteXML(w, http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package api

import (
        "io"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "sss/internal/config"
        "sss/internal/storage"
        "sss/internal/utils"
)

// handleGetObject 获取对象
func (s *Server) handleGetObject(w http.ResponseWriter, r *http.Request, bucket, key string) <span class="cov8" title="1">{
        // 检查存储桶
        b, err := s.metadata.GetBucket(bucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>
        <span class="cov8" title="1">if b == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "/"+bucket)
                return
        }</span>

        // 获取对象元数据
        <span class="cov8" title="1">obj, err := s.metadata.GetObject(bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get object metadata failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>
        <span class="cov8" title="1">if obj == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchKey, http.StatusNotFound, "/"+bucket+"/"+key)
                return
        }</span>

        // 打开文件
        <span class="cov8" title="1">file, err := s.filestore.GetObject(obj.StoragePath)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get object file failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // 处理 Range 请求
        var start, end int64 = 0, obj.Size - 1
        rangeHeader := r.Header.Get("Range")
        if rangeHeader != "" &amp;&amp; obj.Size &gt; 0 </span><span class="cov8" title="1">{
                if strings.HasPrefix(rangeHeader, "bytes=") </span><span class="cov8" title="1">{
                        rangeSpec := strings.TrimPrefix(rangeHeader, "bytes=")
                        parts := strings.Split(rangeSpec, "-")
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                if parts[0] != "" </span><span class="cov8" title="1">{
                                        parsedStart, err := strconv.ParseInt(parts[0], 10, 64)
                                        if err == nil &amp;&amp; parsedStart &gt;= 0 </span><span class="cov8" title="1">{
                                                start = parsedStart
                                        }</span>
                                }
                                <span class="cov8" title="1">if parts[1] != "" </span><span class="cov8" title="1">{
                                        parsedEnd, err := strconv.ParseInt(parts[1], 10, 64)
                                        if err == nil &amp;&amp; parsedEnd &gt;= 0 </span><span class="cov8" title="1">{
                                                end = parsedEnd
                                        }</span>
                                } else<span class="cov8" title="1"> if parts[0] != "" </span><span class="cov8" title="1">{
                                        end = obj.Size - 1
                                }</span>
                        }
                }
                // 验证范围有效性
                <span class="cov8" title="1">if start &lt; 0 </span><span class="cov0" title="0">{
                        start = 0
                }</span>
                <span class="cov8" title="1">if end &gt;= obj.Size </span><span class="cov8" title="1">{
                        end = obj.Size - 1
                }</span>
                <span class="cov8" title="1">if start &gt; end </span><span class="cov8" title="1">{
                        // 无效范围，返回416
                        w.Header().Set("Content-Range", "bytes */"+strconv.FormatInt(obj.Size, 10))
                        w.WriteHeader(http.StatusRequestedRangeNotSatisfiable)
                        return
                }</span>
        }

        // 设置响应头
        <span class="cov8" title="1">w.Header().Set("Content-Type", obj.ContentType)
        w.Header().Set("Content-Length", strconv.FormatInt(end-start+1, 10))
        w.Header().Set("ETag", `"`+obj.ETag+`"`)
        w.Header().Set("Last-Modified", obj.LastModified.UTC().Format(http.TimeFormat))
        w.Header().Set("Accept-Ranges", "bytes")

        if rangeHeader != "" </span><span class="cov8" title="1">{
                // Range 请求：返回 206 Partial Content
                w.Header().Set("Content-Range", "bytes "+strconv.FormatInt(start, 10)+"-"+strconv.FormatInt(end, 10)+"/"+strconv.FormatInt(obj.Size, 10))
                w.WriteHeader(http.StatusPartialContent)
                if start &gt; 0 </span><span class="cov8" title="1">{
                        if _, err := file.Seek(start, 0); err != nil </span><span class="cov0" title="0">{
                                utils.Error("seek file failed", "error", err)
                                return
                        }</span>
                }
                <span class="cov8" title="1">if _, err := io.CopyN(w, file, end-start+1); err != nil </span><span class="cov0" title="0">{
                        // 客户端可能已断开连接，只记录日志
                        utils.Debug("copy to response failed", "error", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // 普通请求：返回 200 OK
                w.WriteHeader(http.StatusOK)
                if _, err := io.Copy(w, file); err != nil </span><span class="cov0" title="0">{
                        // 客户端可能已断开连接，只记录日志
                        utils.Debug("copy to response failed", "error", err)
                }</span>
        }
}

// handlePutObject 上传对象
func (s *Server) handlePutObject(w http.ResponseWriter, r *http.Request, bucket, key string) <span class="cov8" title="1">{
        // 检查存储桶
        b, err := s.metadata.GetBucket(bucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket)
                return
        }</span>
        <span class="cov8" title="1">if b == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "/"+bucket)
                return
        }</span>

        // 验证文件大小限制
        <span class="cov8" title="1">query := r.URL.Query()

        // 1. 检查预签名URL的大小限制（如果有）
        if maxContentLengthStr := query.Get("X-Amz-Max-Content-Length"); maxContentLengthStr != "" </span><span class="cov8" title="1">{
                maxContentLength, err := strconv.ParseInt(maxContentLengthStr, 10, 64)
                if err == nil </span><span class="cov8" title="1">{
                        if r.ContentLength &gt; 0 &amp;&amp; r.ContentLength &gt; maxContentLength </span><span class="cov8" title="1">{
                                utils.WriteError(w, utils.ErrEntityTooLarge, http.StatusBadRequest, "/"+bucket+"/"+key)
                                return
                        }</span>
                }
        }

        // 2. 检查全局最大上传大小限制
        <span class="cov8" title="1">if config.Global.Storage.MaxUploadSize &gt; 0 &amp;&amp; r.ContentLength &gt; 0 </span><span class="cov8" title="1">{
                if r.ContentLength &gt; config.Global.Storage.MaxUploadSize </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrEntityTooLarge, http.StatusBadRequest, "/"+bucket+"/"+key)
                        return
                }</span>
        }

        // 3. 检查全局最大对象大小限制
        <span class="cov8" title="1">if config.Global.Storage.MaxObjectSize &gt; 0 &amp;&amp; r.ContentLength &gt; 0 </span><span class="cov8" title="1">{
                if r.ContentLength &gt; config.Global.Storage.MaxObjectSize </span><span class="cov0" title="0">{
                        utils.WriteError(w, utils.ErrEntityTooLarge, http.StatusBadRequest, "/"+bucket+"/"+key)
                        return
                }</span>
        }

        // 获取 Content-Type
        <span class="cov8" title="1">contentType := r.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov8" title="1">{
                contentType = "application/octet-stream"
        }</span>

        // 4. 验证内容类型限制（如果预签名URL指定了）
        <span class="cov8" title="1">if expectedContentType := query.Get("X-Amz-Content-Type"); expectedContentType != "" </span><span class="cov8" title="1">{
                if contentType != expectedContentType </span><span class="cov8" title="1">{
                        utils.WriteError(w, utils.ErrBadDigest, http.StatusBadRequest, "/"+bucket+"/"+key)
                        return
                }</span>
        }

        // 存储文件
        <span class="cov8" title="1">storagePath, etag, err := s.filestore.PutObject(bucket, key, r.Body, r.ContentLength)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("store object failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        // 保存元数据
        <span class="cov8" title="1">obj := &amp;storage.Object{
                Key:          key,
                Bucket:       bucket,
                Size:         r.ContentLength,
                ETag:         etag,
                ContentType:  contentType,
                LastModified: time.Now().UTC(),
                StoragePath:  storagePath,
        }

        if err := s.metadata.PutObject(obj); err != nil </span><span class="cov0" title="0">{
                utils.Error("save object metadata failed", "error", err)
                s.filestore.DeleteObject(storagePath) // 回滚
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("ETag", `"`+etag+`"`)
        w.WriteHeader(http.StatusOK)</span>
}

// handleDeleteObject 删除对象
func (s *Server) handleDeleteObject(w http.ResponseWriter, r *http.Request, bucket, key string) <span class="cov8" title="1">{
        // 获取对象元数据
        obj, err := s.metadata.GetObject(bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get object metadata failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                return
        }</span>

        <span class="cov8" title="1">if obj != nil </span><span class="cov8" title="1">{
                // 删除文件
                if err := s.filestore.DeleteObject(obj.StoragePath); err != nil </span><span class="cov0" title="0">{
                        utils.Warn("delete object file failed", "error", err)
                }</span>

                // 删除元数据
                <span class="cov8" title="1">if err := s.metadata.DeleteObject(bucket, key); err != nil </span><span class="cov0" title="0">{
                        utils.Error("delete object metadata failed", "error", err)
                        utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+bucket+"/"+key)
                        return
                }</span>
        }

        // S3 删除不存在的对象也返回 204
        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// handleCopyObject 复制对象
func (s *Server) handleCopyObject(w http.ResponseWriter, r *http.Request, destBucket, destKey string) <span class="cov8" title="1">{
        // 解析源对象路径
        copySource := r.Header.Get("x-amz-copy-source")
        if copySource == "" </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrInvalidArgument, http.StatusBadRequest, "/"+destBucket+"/"+destKey)
                return
        }</span>

        // URL解码源路径（处理中文文件名等）
        <span class="cov8" title="1">decodedSource, err := url.PathUnescape(copySource)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteErrorResponse(w, "InvalidCopySource", "Invalid x-amz-copy-source encoding", http.StatusBadRequest)
                return
        }</span>

        // 解析源路径，格式: /bucket/key 或 bucket/key
        <span class="cov8" title="1">decodedSource = strings.TrimPrefix(decodedSource, "/")
        parts := strings.SplitN(decodedSource, "/", 2)
        if len(parts) != 2 || parts[0] == "" || parts[1] == "" </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidCopySource", "Invalid x-amz-copy-source format", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">srcBucket := parts[0]
        srcKey := parts[1]

        // 验证路径安全性（防止路径遍历）
        if strings.Contains(srcBucket, "..") || strings.ContainsAny(srcBucket, "/\\") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidCopySource", "Invalid source bucket name", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if strings.Contains(srcKey, "..") </span><span class="cov8" title="1">{
                utils.WriteErrorResponse(w, "InvalidCopySource", "Invalid source key", http.StatusBadRequest)
                return
        }</span>

        // 检查源存储桶
        <span class="cov8" title="1">srcB, err := s.metadata.GetBucket(srcBucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check source bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+srcBucket)
                return
        }</span>
        <span class="cov8" title="1">if srcB == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "/"+srcBucket)
                return
        }</span>

        // 检查目标存储桶
        <span class="cov8" title="1">destB, err := s.metadata.GetBucket(destBucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check dest bucket failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+destBucket)
                return
        }</span>
        <span class="cov8" title="1">if destB == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchBucket, http.StatusNotFound, "/"+destBucket)
                return
        }</span>

        // 获取源对象元数据
        <span class="cov8" title="1">srcObj, err := s.metadata.GetObject(srcBucket, srcKey)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get source object metadata failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+srcBucket+"/"+srcKey)
                return
        }</span>
        <span class="cov8" title="1">if srcObj == nil </span><span class="cov8" title="1">{
                utils.WriteError(w, utils.ErrNoSuchKey, http.StatusNotFound, "/"+srcBucket+"/"+srcKey)
                return
        }</span>

        // 复制文件
        <span class="cov8" title="1">newStoragePath, etag, err := s.filestore.CopyObject(srcObj.StoragePath, destBucket, destKey)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("copy object file failed", "error", err)
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+destBucket+"/"+destKey)
                return
        }</span>

        // 保存新对象元数据
        <span class="cov8" title="1">newObj := &amp;storage.Object{
                Key:          destKey,
                Bucket:       destBucket,
                Size:         srcObj.Size,
                ETag:         etag,
                ContentType:  srcObj.ContentType,
                LastModified: time.Now().UTC(),
                StoragePath:  newStoragePath,
        }

        if err := s.metadata.PutObject(newObj); err != nil </span><span class="cov0" title="0">{
                utils.Error("save copied object metadata failed", "error", err)
                s.filestore.DeleteObject(newStoragePath) // 回滚
                utils.WriteError(w, utils.ErrInternalError, http.StatusInternalServerError, "/"+destBucket+"/"+destKey)
                return
        }</span>

        // 返回 S3 CopyObject 响应格式
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/xml")
        w.WriteHeader(http.StatusOK)
        response := `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;CopyObjectResult&gt;
  &lt;LastModified&gt;` + newObj.LastModified.Format(time.RFC3339) + `&lt;/LastModified&gt;
  &lt;ETag&gt;"` + etag + `"&lt;/ETag&gt;
&lt;/CopyObjectResult&gt;`
        w.Write([]byte(response))</span>
}

// handleHeadObject 获取对象元数据
func (s *Server) handleHeadObject(w http.ResponseWriter, r *http.Request, bucket, key string) <span class="cov8" title="1">{
        // 检查存储桶
        b, err := s.metadata.GetBucket(bucket)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("check bucket failed", "error", err)
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if b == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>

        // 获取对象元数据
        <span class="cov8" title="1">obj, err := s.metadata.GetObject(bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("get object metadata failed", "error", err)
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if obj == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", obj.ContentType)
        w.Header().Set("Content-Length", strconv.FormatInt(obj.Size, 10))
        w.Header().Set("ETag", `"`+obj.ETag+`"`)
        w.Header().Set("Last-Modified", obj.LastModified.UTC().Format(http.TimeFormat))
        w.Header().Set("Accept-Ranges", "bytes")
        w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package api

import (
        "fmt"
        "io"
        "io/fs"
        "net/http"
        "path/filepath"
        "strings"
)

// 静态文件系统（由 embed.go 或 embed_dev.go 初始化）
var staticFS fs.FS
var useEmbed bool

// serveStatic 处理静态文件请求
func (s *Server) serveStatic(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // 获取请求路径
        path := r.URL.Path

        // 如果是根路径，返回 index.html
        if path == "/" </span><span class="cov8" title="1">{
                s.serveStaticFile(w, r, "index.html")
                return
        }</span>

        // 处理 hash 路由
        <span class="cov8" title="1">if strings.Contains(path, "#") </span><span class="cov0" title="0">{
                s.serveStaticFile(w, r, "index.html")
                return
        }</span>

        // 处理静态资源（去掉开头的斜杠）
        <span class="cov8" title="1">if strings.HasPrefix(path, "/assets/") </span><span class="cov8" title="1">{
                s.serveStaticFile(w, r, path[1:]) // 去掉开头的 /
                return
        }</span>

        // 处理根目录静态文件（favicon.svg, robots.txt 等）
        <span class="cov8" title="1">if strings.HasSuffix(path, ".svg") || strings.HasSuffix(path, ".ico") ||
                strings.HasSuffix(path, ".png") || strings.HasSuffix(path, ".txt") </span><span class="cov0" title="0">{
                s.serveStaticFile(w, r, path[1:]) // 去掉开头的 /
                return
        }</span>

        // 其他路径也返回 index.html (SPA 路由)
        <span class="cov8" title="1">s.serveStaticFile(w, r, "index.html")</span>
}

// serveStaticFile 从文件系统或嵌入文件发送文件
func (s *Server) serveStaticFile(w http.ResponseWriter, r *http.Request, name string) <span class="cov8" title="1">{
        // 打开文件
        f, err := staticFS.Open(name)
        if err != nil </span><span class="cov8" title="1">{
                http.NotFound(w, r)
                return
        }</span>
        <span class="cov0" title="0">defer f.Close()

        // 获取文件信息
        stat, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>

        // 如果是目录，尝试 index.html
        <span class="cov0" title="0">if stat.IsDir() </span><span class="cov0" title="0">{
                indexPath := filepath.Join(name, "index.html")
                f2, err := staticFS.Open(indexPath)
                if err != nil </span><span class="cov0" title="0">{
                        http.NotFound(w, r)
                        return
                }</span>
                <span class="cov0" title="0">defer f2.Close()
                f = f2
                stat, _ = f2.Stat()
                name = indexPath</span>
        }

        // 设置 Content-Type
        <span class="cov0" title="0">ext := filepath.Ext(name)
        switch ext </span>{
        case ".html":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/html; charset=utf-8")</span>
        case ".css":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/css; charset=utf-8")</span>
        case ".js":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/javascript; charset=utf-8")</span>
        case ".png":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "image/png")</span>
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "image/jpeg")</span>
        case ".gif":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "image/gif")</span>
        case ".svg":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "image/svg+xml")</span>
        case ".ico":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "image/x-icon")</span>
        case ".json":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/json; charset=utf-8")</span>
        case ".woff":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "font/woff")</span>
        case ".woff2":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "font/woff2")</span>
        case ".ttf":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "font/ttf")</span>
        }

        // 如果支持 ReadSeeker，使用 http.ServeContent（支持 Range 请求）
        <span class="cov0" title="0">if rs, ok := f.(io.ReadSeeker); ok </span><span class="cov0" title="0">{
                http.ServeContent(w, r, name, stat.ModTime(), rs)
                return
        }</span>

        // 否则直接复制内容
        <span class="cov0" title="0">w.Header().Set("Content-Length", fmt.Sprintf("%d", stat.Size()))
        if _, err := io.Copy(w, f); err != nil </span><span class="cov0" title="0">{
                // 客户端可能已断开连接，忽略错误
                return
        }</span>
}

// IsEmbedMode 返回是否使用嵌入模式
func IsEmbedMode() bool <span class="cov8" title="1">{
        return useEmbed
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package auth

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "net/url"
        "sort"
        "strings"
        "time"

        "sss/internal/config"
)

// PresignOptions 预签名URL选项
type PresignOptions struct {
        MaxContentLength int64     // 最大内容长度（字节），0表示不限制
        ContentType      string    // 限制内容类型
        Expires          time.Duration // 过期时间
}

// GeneratePresignedURL 生成预签名 URL（向后兼容）
func GeneratePresignedURL(method, bucket, key string, expires time.Duration) string <span class="cov8" title="1">{
        return GeneratePresignedURLWithOptions(method, bucket, key, &amp;PresignOptions{
                Expires: expires,
        })
}</span>

// GeneratePresignedURLWithOptions 生成带选项的预签名 URL
func GeneratePresignedURLWithOptions(method, bucket, key string, opts *PresignOptions) string <span class="cov8" title="1">{
        cfg := config.Global

        // 构建 URL
        host := fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port)
        if cfg.Server.Host == "0.0.0.0" </span><span class="cov8" title="1">{
                host = fmt.Sprintf("localhost:%d", cfg.Server.Port)
        }</span>

        <span class="cov8" title="1">path := fmt.Sprintf("/%s/%s", bucket, key)

        now := time.Now().UTC()
        dateStr := now.Format("20060102")
        amzDate := now.Format("20060102T150405Z")

        credential := fmt.Sprintf("%s/%s/%s/s3/aws4_request",
                cfg.Auth.AccessKeyID, dateStr, cfg.Server.Region)

        // 构建查询参数
        params := url.Values{
                "X-Amz-Algorithm":     {algorithm},
                "X-Amz-Credential":    {credential},
                "X-Amz-Date":          {amzDate},
                "X-Amz-Expires":       {fmt.Sprintf("%d", int(opts.Expires.Seconds()))},
                "X-Amz-SignedHeaders": {"host"},
        }

        // 添加内容长度限制（如果指定）
        if opts.MaxContentLength &gt; 0 </span><span class="cov8" title="1">{
                // 确保不超过全局限制
                maxLength := opts.MaxContentLength
                if cfg.Storage.MaxUploadSize &gt; 0 &amp;&amp; maxLength &gt; cfg.Storage.MaxUploadSize </span><span class="cov8" title="1">{
                        maxLength = cfg.Storage.MaxUploadSize
                }</span>
                <span class="cov8" title="1">params.Add("X-Amz-Max-Content-Length", fmt.Sprintf("%d", maxLength))</span>
        }

        // 添加内容类型限制（如果指定）
        <span class="cov8" title="1">if opts.ContentType != "" </span><span class="cov8" title="1">{
                params.Add("X-Amz-Content-Type", opts.ContentType)
        }</span>

        // 规范查询字符串
        <span class="cov8" title="1">canonicalQuery := getCanonicalQueryStringForPresign(params)

        // 构建签名头
        signedHeaders := "host"
        if opts.ContentType != "" </span><span class="cov8" title="1">{
                signedHeaders = "host;content-type"
        }</span>

        // 规范请求
        <span class="cov8" title="1">canonicalHeaders := fmt.Sprintf("host:%s\n", host)
        canonicalRequest := fmt.Sprintf("%s\n%s\n%s\n%s\n%s\n%s",
                method,
                path,
                canonicalQuery,
                canonicalHeaders,
                signedHeaders,
                unsignedPayload,
        )

        // 待签名字符串
        scope := fmt.Sprintf("%s/%s/s3/aws4_request", dateStr, cfg.Server.Region)
        hash := sha256.Sum256([]byte(canonicalRequest))
        stringToSign := fmt.Sprintf("%s\n%s\n%s\n%s",
                algorithm,
                amzDate,
                scope,
                hex.EncodeToString(hash[:]),
        )

        // 计算签名
        signingKey := deriveSigningKey(cfg.Auth.SecretAccessKey, dateStr, cfg.Server.Region)
        signature := hex.EncodeToString(hmacSHA256(signingKey, []byte(stringToSign)))

        // 构建最终 URL（使用可配置的协议）
        scheme := "http"
        if cfg.Security.PresignScheme != "" </span><span class="cov8" title="1">{
                scheme = cfg.Security.PresignScheme
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s://%s%s?%s&amp;X-Amz-Signature=%s",
                scheme, host, path, canonicalQuery, signature)</span>
}

func getCanonicalQueryStringForPresign(params url.Values) string <span class="cov8" title="1">{
        var keys []string
        for k := range params </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        var pairs []string
        for _, k := range keys </span><span class="cov8" title="1">{
                for _, v := range params[k] </span><span class="cov8" title="1">{
                        pairs = append(pairs, fmt.Sprintf("%s=%s", url.QueryEscape(k), url.QueryEscape(v)))
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(pairs, "&amp;")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package auth

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "regexp"
        "sort"
        "strings"
        "time"

        "sss/internal/config"
        "sss/internal/storage"
        "sss/internal/utils"
)

// 全局 API Key 缓存
var apiKeyCache *storage.APIKeyCache

// InitAPIKeyCache 初始化 API Key 缓存
func InitAPIKeyCache(store *storage.MetadataStore) <span class="cov8" title="1">{
        apiKeyCache = storage.NewAPIKeyCache(store)
}</span>

// ReloadAPIKeyCache 重新加载 API Key 缓存
func ReloadAPIKeyCache() error <span class="cov8" title="1">{
        if apiKeyCache != nil </span><span class="cov8" title="1">{
                return apiKeyCache.Reload()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CheckBucketPermission 检查 API Key 对桶的访问权限
func CheckBucketPermission(accessKeyID, bucket string, needWrite bool) bool <span class="cov8" title="1">{
        // 如果使用旧配置的管理员 Key，拥有全部权限
        if config.Global.Auth.AccessKeyID != "" &amp;&amp;
                accessKeyID == config.Global.Auth.AccessKeyID </span><span class="cov8" title="1">{
                return true
        }</span>

        // 从缓存检查权限
        <span class="cov8" title="1">if apiKeyCache != nil </span><span class="cov0" title="0">{
                return apiKeyCache.CheckPermission(accessKeyID, bucket, needWrite)
        }</span>
        <span class="cov8" title="1">return false</span>
}

const (
        algorithm       = "AWS4-HMAC-SHA256"
        serviceName     = "s3"
        terminationStr  = "aws4_request"
        unsignedPayload = "UNSIGNED-PAYLOAD"
)

// 解析 Authorization 头
var authHeaderRegex = regexp.MustCompile(`AWS4-HMAC-SHA256\s+Credential=([^/]+)/(\d{8})/([^/]+)/s3/aws4_request,\s*SignedHeaders=([^,]+),\s*Signature=([a-f0-9]+)`)

// VerifyRequest 验证请求签名，返回是否验证成功
func VerifyRequest(r *http.Request) bool <span class="cov8" title="1">{
        _, ok := VerifyRequestAndGetAccessKey(r)
        return ok
}</span>

// VerifyRequestAndGetAccessKey 验证请求签名并返回 Access Key ID
func VerifyRequestAndGetAccessKey(r *http.Request) (string, bool) <span class="cov8" title="1">{
        // 检查是否是预签名 URL
        if r.URL.Query().Get("X-Amz-Signature") != "" </span><span class="cov0" title="0">{
                return verifyPresignedURL(r)
        }</span>

        <span class="cov8" title="1">authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">matches := authHeaderRegex.FindStringSubmatch(authHeader)
        if matches == nil </span><span class="cov8" title="1">{
                utils.Debug("invalid auth header format", "header", authHeader)
                return "", false
        }</span>

        <span class="cov8" title="1">accessKey := matches[1]
        dateStr := matches[2]
        region := matches[3]
        signedHeaders := matches[4]
        signature := matches[5]

        // 获取对应的 Secret Key
        secretKey := getSecretKey(accessKey)
        if secretKey == "" </span><span class="cov8" title="1">{
                utils.Debug("invalid access key", "got", accessKey)
                return "", false
        }</span>

        // 计算签名
        <span class="cov8" title="1">calculatedSig := calculateSignatureWithSecret(r, dateStr, region, signedHeaders, secretKey)
        if calculatedSig != signature </span><span class="cov8" title="1">{
                utils.Debug("signature mismatch", "calculated", calculatedSig, "provided", signature)
                return "", false
        }</span>

        <span class="cov8" title="1">return accessKey, true</span>
}

// getSecretKey 获取 Access Key 对应的 Secret Key
func getSecretKey(accessKeyID string) string <span class="cov8" title="1">{
        // 先检查旧配置中的管理员 Key
        if config.Global.Auth.AccessKeyID != "" &amp;&amp;
                accessKeyID == config.Global.Auth.AccessKeyID </span><span class="cov8" title="1">{
                return config.Global.Auth.SecretAccessKey
        }</span>

        // 从缓存中获取
        <span class="cov8" title="1">if apiKeyCache != nil </span><span class="cov8" title="1">{
                if secret, ok := apiKeyCache.GetSecretKey(accessKeyID); ok </span><span class="cov0" title="0">{
                        return secret
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// calculateSignature 计算请求签名（使用配置中的密钥，兼容旧代码）
func calculateSignature(r *http.Request, dateStr, region, signedHeaders string) string <span class="cov0" title="0">{
        return calculateSignatureWithSecret(r, dateStr, region, signedHeaders, config.Global.Auth.SecretAccessKey)
}</span>

// calculateSignatureWithSecret 使用指定密钥计算请求签名
func calculateSignatureWithSecret(r *http.Request, dateStr, region, signedHeaders, secretKey string) string <span class="cov8" title="1">{
        // 获取请求时间
        amzDate := r.Header.Get("X-Amz-Date")
        if amzDate == "" </span><span class="cov0" title="0">{
                amzDate = r.Header.Get("Date")
        }</span>

        // 1. 创建规范请求
        <span class="cov8" title="1">canonicalRequest := createCanonicalRequest(r, signedHeaders)
        utils.Debug("canonical request", "request", canonicalRequest)

        // 2. 创建待签名字符串
        scope := fmt.Sprintf("%s/%s/%s/%s", dateStr, region, serviceName, terminationStr)
        stringToSign := createStringToSign(amzDate, scope, canonicalRequest)
        utils.Debug("string to sign", "string", stringToSign)

        // 3. 计算签名
        signingKey := deriveSigningKey(secretKey, dateStr, region)
        signature := hex.EncodeToString(hmacSHA256(signingKey, []byte(stringToSign)))

        return signature</span>
}

// createCanonicalRequest 创建规范请求
func createCanonicalRequest(r *http.Request, signedHeaders string) string <span class="cov8" title="1">{
        // HTTP 方法
        method := r.Method

        // 规范 URI
        canonicalURI := getCanonicalURI(r.URL.Path)

        // 规范查询字符串
        canonicalQuery := getCanonicalQueryString(r.URL.Query())

        // 规范头部
        headerList := strings.Split(signedHeaders, ";")
        var canonicalHeaders strings.Builder
        for _, h := range headerList </span><span class="cov8" title="1">{
                h = strings.ToLower(h)
                var value string
                if h == "host" </span><span class="cov8" title="1">{
                        value = r.Host
                }</span> else<span class="cov8" title="1"> {
                        value = r.Header.Get(h)
                }</span>
                <span class="cov8" title="1">canonicalHeaders.WriteString(fmt.Sprintf("%s:%s\n", h, strings.TrimSpace(value)))</span>
        }

        // Payload 哈希
        <span class="cov8" title="1">payloadHash := r.Header.Get("X-Amz-Content-Sha256")
        if payloadHash == "" </span><span class="cov8" title="1">{
                payloadHash = unsignedPayload
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s\n%s\n%s\n%s\n%s\n%s",
                method,
                canonicalURI,
                canonicalQuery,
                canonicalHeaders.String(),
                signedHeaders,
                payloadHash,
        )</span>
}

// createStringToSign 创建待签名字符串
func createStringToSign(dateTime, scope, canonicalRequest string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(canonicalRequest))
        return fmt.Sprintf("%s\n%s\n%s\n%s",
                algorithm,
                dateTime,
                scope,
                hex.EncodeToString(hash[:]),
        )
}</span>

// deriveSigningKey 派生签名密钥
func deriveSigningKey(secret, dateStr, region string) []byte <span class="cov8" title="1">{
        kDate := hmacSHA256([]byte("AWS4"+secret), []byte(dateStr))
        kRegion := hmacSHA256(kDate, []byte(region))
        kService := hmacSHA256(kRegion, []byte(serviceName))
        kSigning := hmacSHA256(kService, []byte(terminationStr))
        return kSigning
}</span>

// hmacSHA256 计算 HMAC-SHA256
func hmacSHA256(key, data []byte) []byte <span class="cov8" title="1">{
        h := hmac.New(sha256.New, key)
        h.Write(data)
        return h.Sum(nil)
}</span>

// getCanonicalURI 获取规范 URI
func getCanonicalURI(path string) string <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return "/"
        }</span>
        // URI 编码，但保留斜杠
        <span class="cov8" title="1">segments := strings.Split(path, "/")
        for i, seg := range segments </span><span class="cov8" title="1">{
                segments[i] = url.PathEscape(seg)
        }</span>
        <span class="cov8" title="1">return strings.Join(segments, "/")</span>
}

// getCanonicalQueryString 获取规范查询字符串
func getCanonicalQueryString(query url.Values) string <span class="cov8" title="1">{
        // 移除签名相关参数
        delete(query, "X-Amz-Signature")

        if len(query) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var keys []string
        for k := range query </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        var pairs []string
        for _, k := range keys </span><span class="cov8" title="1">{
                values := query[k]
                sort.Strings(values)
                for _, v := range values </span><span class="cov8" title="1">{
                        pairs = append(pairs, fmt.Sprintf("%s=%s", url.QueryEscape(k), url.QueryEscape(v)))
                }</span>
        }

        <span class="cov8" title="1">return strings.Join(pairs, "&amp;")</span>
}

// verifyPresignedURL 验证预签名 URL，返回 access key ID
func verifyPresignedURL(r *http.Request) (string, bool) <span class="cov8" title="1">{
        query := r.URL.Query()

        // 解析参数
        credential := query.Get("X-Amz-Credential")
        if credential == "" </span><span class="cov8" title="1">{
                return "", false
        }</span>
        // Credential 格式: accessKey/date/region/s3/aws4_request
        <span class="cov8" title="1">parts := strings.Split(credential, "/")
        if len(parts) != 5 </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">accessKeyID := parts[0]
        dateStr := parts[1]
        region := parts[2]

        // 获取对应的 Secret Key
        secretKey := getSecretKey(accessKeyID)
        if secretKey == "" </span><span class="cov8" title="1">{
                utils.Debug("invalid access key in presigned URL", "got", accessKeyID)
                return "", false
        }</span>

        // 检查过期时间
        <span class="cov8" title="1">amzDate := query.Get("X-Amz-Date")
        expires := query.Get("X-Amz-Expires")
        if amzDate == "" || expires == "" </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">t, err := time.Parse("20060102T150405Z", amzDate)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov8" title="1">var expireSec int
        fmt.Sscanf(expires, "%d", &amp;expireSec)
        if time.Now().After(t.Add(time.Duration(expireSec) * time.Second)) </span><span class="cov0" title="0">{
                utils.Debug("presigned URL expired")
                return "", false
        }</span>

        // 验证签名
        <span class="cov8" title="1">providedSig := query.Get("X-Amz-Signature")
        signedHeaders := query.Get("X-Amz-SignedHeaders")
        if signedHeaders == "" </span><span class="cov8" title="1">{
                signedHeaders = "host"
        }</span>

        // 创建规范请求（不包含 X-Amz-Signature）
        <span class="cov8" title="1">queryWithoutSig := make(url.Values)
        for k, v := range query </span><span class="cov8" title="1">{
                if k != "X-Amz-Signature" </span><span class="cov8" title="1">{
                        queryWithoutSig[k] = v
                }</span>
        }

        // 对URL路径进行解码，因为浏览器会自动编码中文字符
        // 但生成预签名URL时使用的是原始未编码的路径
        <span class="cov8" title="1">decodedPath, err := url.PathUnescape(r.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                utils.Debug("failed to decode path", "path", r.URL.Path, "error", err)
                decodedPath = r.URL.Path // 解码失败则使用原路径
        }</span>
        <span class="cov8" title="1">canonicalURI := decodedPath
        canonicalQuery := getCanonicalQueryString(queryWithoutSig)

        headerList := strings.Split(signedHeaders, ";")
        var canonicalHeaders strings.Builder
        for _, h := range headerList </span><span class="cov8" title="1">{
                h = strings.ToLower(h)
                var value string
                if h == "host" </span><span class="cov8" title="1">{
                        value = r.Host
                }</span> else<span class="cov0" title="0"> {
                        value = r.Header.Get(h)
                }</span>
                <span class="cov8" title="1">canonicalHeaders.WriteString(fmt.Sprintf("%s:%s\n", h, strings.TrimSpace(value)))</span>
        }

        <span class="cov8" title="1">canonicalRequest := fmt.Sprintf("%s\n%s\n%s\n%s\n%s\n%s",
                r.Method,
                canonicalURI,
                canonicalQuery,
                canonicalHeaders.String(),
                signedHeaders,
                unsignedPayload,
        )

        scope := fmt.Sprintf("%s/%s/%s/%s", dateStr, region, serviceName, terminationStr)
        stringToSign := createStringToSign(amzDate, scope, canonicalRequest)
        signingKey := deriveSigningKey(secretKey, dateStr, region)
        calculatedSig := hex.EncodeToString(hmacSHA256(signingKey, []byte(stringToSign)))

        if calculatedSig == providedSig </span><span class="cov0" title="0">{
                return accessKeyID, true
        }</span>
        <span class="cov8" title="1">return "", false</span>
}

// GetPayloadHash 计算请求体哈希
func GetPayloadHash(r *http.Request) string <span class="cov8" title="1">{
        if r.Body == nil </span><span class="cov0" title="0">{
                return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" // empty string hash
        }</span>

        <span class="cov8" title="1">body, _ := io.ReadAll(r.Body)
        hash := sha256.Sum256(body)
        return hex.EncodeToString(hash[:])</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package config

import (
        "strconv"
)

// Config 运行时配置（不再从 YAML 加载，全部从命令行参数和数据库获取）
type Config struct {
        Server   ServerConfig
        Storage  StorageConfig
        Auth     AuthConfig
        Security SecurityConfig
        Log      LogConfig
}

// SecurityConfig 安全配置
type SecurityConfig struct {
        CORSOrigin    string // CORS 允许的来源，默认 "*"
        PresignScheme string // 预签名URL协议，"http" 或 "https"，默认 "http"
}

// ServerConfig 服务器配置（启动时通过命令行参数设置，运行时不可改）
type ServerConfig struct {
        Host   string // 监听地址，命令行参数
        Port   int    // 监听端口，命令行参数
        Region string // S3 区域，可在线修改
}

// StorageConfig 存储配置
type StorageConfig struct {
        DataPath      string // 数据目录，命令行参数（运行时不可改）
        DBPath        string // 数据库路径，命令行参数（运行时不可改）
        MaxObjectSize int64  // 最大对象大小，可在线修改
        MaxUploadSize int64  // 最大上传大小，可在线修改
}

// AuthConfig 认证配置
type AuthConfig struct {
        AdminUsername   string // 管理员用户名
        AccessKeyID     string // 默认 API Key ID
        SecretAccessKey string // 默认 API Key Secret
        PasswordHashed  bool   // 密码是否已哈希（从数据库加载时为 true）
}

// LogConfig 日志配置
type LogConfig struct {
        Level string
}

// Global 全局配置实例
var Global *Config

// NewDefault 创建默认配置
func NewDefault() *Config <span class="cov8" title="1">{
        cfg := &amp;Config{
                Server: ServerConfig{
                        Host:   "0.0.0.0",
                        Port:   8080,
                        Region: "us-east-1",
                },
                Storage: StorageConfig{
                        DataPath:      "./data/buckets",
                        DBPath:        "./data/metadata.db",
                        MaxObjectSize: 5 * 1024 * 1024 * 1024, // 5GB
                        MaxUploadSize: 1024 * 1024 * 1024,     // 1GB
                },
                Auth: AuthConfig{
                        AdminUsername: "admin",
                },
                Security: SecurityConfig{
                        CORSOrigin:    "*",    // 默认允许所有来源
                        PresignScheme: "http", // 默认 HTTP
                },
                Log: LogConfig{
                        Level: "info",
                },
        }
        Global = cfg
        return cfg
}</span>

// SettingsLoader 数据库配置加载接口
type SettingsLoader interface {
        GetSetting(key string) (string, error)
        IsInstalled() bool
        GetAdminUsername() string
        VerifyAdminPassword(password string) bool
        GetAuthConfig() (accessKeyID, secretAccessKey string)
        GetStorageConfig() (dataPath string, maxObjectSize, maxUploadSize int64)
}

// LoadFromDB 从数据库加载可修改的配置（Region、存储限制等）
// 注意：Host、Port、DataPath、DBPath 保持命令行参数值，不从数据库覆盖
func LoadFromDB(loader SettingsLoader) <span class="cov8" title="1">{
        if Global == nil </span><span class="cov8" title="1">{
                Global = NewDefault()
        }</span>

        // 如果系统已安装，从数据库加载配置
        <span class="cov8" title="1">if loader.IsInstalled() </span><span class="cov8" title="1">{
                // 只加载 Region（Host/Port 由命令行参数决定）
                if region, err := loader.GetSetting("server.region"); err == nil &amp;&amp; region != "" </span><span class="cov8" title="1">{
                        Global.Server.Region = region
                }</span>

                // 存储配置（只加载大小限制，DataPath 由命令行参数决定）
                <span class="cov8" title="1">_, maxObjSize, maxUploadSize := loader.GetStorageConfig()
                if maxObjSize &gt; 0 </span><span class="cov8" title="1">{
                        Global.Storage.MaxObjectSize = maxObjSize
                }</span>
                <span class="cov8" title="1">if maxUploadSize &gt; 0 </span><span class="cov8" title="1">{
                        Global.Storage.MaxUploadSize = maxUploadSize
                }</span>

                // 安全配置
                <span class="cov8" title="1">if corsOrigin, err := loader.GetSetting("security.cors_origin"); err == nil &amp;&amp; corsOrigin != "" </span><span class="cov8" title="1">{
                        Global.Security.CORSOrigin = corsOrigin
                }</span>
                <span class="cov8" title="1">if presignScheme, err := loader.GetSetting("security.presign_scheme"); err == nil &amp;&amp; presignScheme != "" </span><span class="cov8" title="1">{
                        Global.Security.PresignScheme = presignScheme
                }</span>

                // 认证配置
                <span class="cov8" title="1">Global.Auth.AdminUsername = loader.GetAdminUsername()
                Global.Auth.PasswordHashed = true

                // API Key
                accessKeyID, secretAccessKey := loader.GetAuthConfig()
                if accessKeyID != "" </span><span class="cov8" title="1">{
                        Global.Auth.AccessKeyID = accessKeyID
                        Global.Auth.SecretAccessKey = secretAccessKey
                }</span>
        }
}

// UpdateFromSettings 从数据库设置更新运行时配置
func UpdateFromSettings(settings map[string]string) <span class="cov8" title="1">{
        if Global == nil </span><span class="cov8" title="1">{
                Global = NewDefault()
        }</span>

        // 只更新运行时可修改的配置
        <span class="cov8" title="1">if v, ok := settings["server.region"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                Global.Server.Region = v
        }</span>
        <span class="cov8" title="1">if v, ok := settings["storage.max_object_size"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                if size, err := strconv.ParseInt(v, 10, 64); err == nil &amp;&amp; size &gt; 0 </span><span class="cov8" title="1">{
                        Global.Storage.MaxObjectSize = size
                }</span>
        }
        <span class="cov8" title="1">if v, ok := settings["storage.max_upload_size"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                if size, err := strconv.ParseInt(v, 10, 64); err == nil &amp;&amp; size &gt; 0 </span><span class="cov8" title="1">{
                        Global.Storage.MaxUploadSize = size
                }</span>
        }
        <span class="cov8" title="1">if v, ok := settings["auth.admin_username"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                Global.Auth.AdminUsername = v
        }</span>
        <span class="cov8" title="1">if v, ok := settings["auth.access_key_id"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                Global.Auth.AccessKeyID = v
        }</span>
        <span class="cov8" title="1">if v, ok := settings["auth.secret_access_key"]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                Global.Auth.SecretAccessKey = v
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package storage

import (
        "crypto/rand"
        "crypto/subtle"
        "database/sql"
        "encoding/hex"
        "sync"
        "time"
)

// APIKey API密钥
type APIKey struct {
        AccessKeyID     string    `json:"access_key_id"`
        SecretAccessKey string    `json:"secret_access_key,omitempty"` // 仅创建时返回
        Description     string    `json:"description"`
        CreatedAt       time.Time `json:"created_at"`
        Enabled         bool      `json:"enabled"`
}

// APIKeyPermission API密钥权限
type APIKeyPermission struct {
        AccessKeyID string `json:"access_key_id"`
        BucketName  string `json:"bucket_name"` // "*" 表示所有桶
        CanRead     bool   `json:"can_read"`
        CanWrite    bool   `json:"can_write"`
}

// APIKeyWithPermissions API密钥及其权限
type APIKeyWithPermissions struct {
        APIKey
        Permissions []APIKeyPermission `json:"permissions"`
}

// CachedAPIKey 缓存的API密钥（包含权限）
type CachedAPIKey struct {
        SecretAccessKey string
        Enabled         bool
        Permissions     map[string]*APIKeyPermission // bucket_name -&gt; permission
}

// APIKeyCache API密钥缓存
type APIKeyCache struct {
        mu    sync.RWMutex
        keys  map[string]*CachedAPIKey // access_key_id -&gt; cached key
        store *MetadataStore
}

// NewAPIKeyCache 创建API密钥缓存
func NewAPIKeyCache(store *MetadataStore) *APIKeyCache <span class="cov8" title="1">{
        cache := &amp;APIKeyCache{
                keys:  make(map[string]*CachedAPIKey),
                store: store,
        }
        // 初始化时加载所有API密钥
        cache.Reload()
        return cache
}</span>

// Reload 重新加载所有API密钥到缓存
func (c *APIKeyCache) Reload() error <span class="cov8" title="1">{
        keys, err := c.store.ListAPIKeysWithPermissions()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()

        // 清空并重建缓存
        c.keys = make(map[string]*CachedAPIKey)
        for _, key := range keys </span><span class="cov8" title="1">{
                cached := &amp;CachedAPIKey{
                        SecretAccessKey: key.SecretAccessKey,
                        Enabled:         key.Enabled,
                        Permissions:     make(map[string]*APIKeyPermission),
                }
                for i := range key.Permissions </span><span class="cov8" title="1">{
                        perm := key.Permissions[i]
                        cached.Permissions[perm.BucketName] = &amp;perm
                }</span>
                <span class="cov8" title="1">c.keys[key.AccessKeyID] = cached</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Validate 验证API密钥
func (c *APIKeyCache) Validate(accessKeyID, secretAccessKey string) bool <span class="cov8" title="1">{
        c.mu.RLock()
        cached, exists := c.keys[accessKeyID]
        c.mu.RUnlock()

        if !exists || !cached.Enabled </span><span class="cov8" title="1">{
                return false
        }</span>

        // 使用常量时间比较防止时序攻击
        <span class="cov8" title="1">return subtle.ConstantTimeCompare([]byte(cached.SecretAccessKey), []byte(secretAccessKey)) == 1</span>
}

// GetSecretKey 获取API密钥的SecretKey（用于签名验证）
func (c *APIKeyCache) GetSecretKey(accessKeyID string) (string, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        cached, exists := c.keys[accessKeyID]
        c.mu.RUnlock()

        if !exists || !cached.Enabled </span><span class="cov8" title="1">{
                return "", false
        }</span>
        <span class="cov8" title="1">return cached.SecretAccessKey, true</span>
}

// CheckPermission 检查API密钥的桶权限
func (c *APIKeyCache) CheckPermission(accessKeyID, bucketName string, needWrite bool) bool <span class="cov8" title="1">{
        c.mu.RLock()
        cached, exists := c.keys[accessKeyID]
        c.mu.RUnlock()

        if !exists || !cached.Enabled </span><span class="cov8" title="1">{
                return false
        }</span>

        // 先检查通配符权限
        <span class="cov8" title="1">if perm, ok := cached.Permissions["*"]; ok </span><span class="cov8" title="1">{
                if needWrite </span><span class="cov8" title="1">{
                        return perm.CanWrite
                }</span>
                <span class="cov8" title="1">return perm.CanRead</span>
        }

        // 检查特定桶权限
        <span class="cov8" title="1">perm, ok := cached.Permissions[bucketName]
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if needWrite </span><span class="cov8" title="1">{
                return perm.CanWrite
        }</span>
        <span class="cov8" title="1">return perm.CanRead</span>
}

// === MetadataStore API Key 操作 ===

// CreateAPIKey 创建API密钥（SecretKey 加密存储）
func (m *MetadataStore) CreateAPIKey(description string) (*APIKey, error) <span class="cov8" title="1">{
        accessKeyID := generateRandomKey(20)
        secretAccessKey := generateRandomKey(40)

        // 加密 SecretKey
        encryptedSecret, err := m.EncryptSecret(secretAccessKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">createdAt := time.Now().UTC()
        err = m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(`
                        INSERT INTO api_keys (access_key_id, secret_access_key, description, created_at, enabled)
                        VALUES (?, ?, ?, ?, 1)`,
                        accessKeyID, encryptedSecret, description, createdAt,
                )
                return err
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;APIKey{
                AccessKeyID:     accessKeyID,
                SecretAccessKey: secretAccessKey, // 返回明文给用户
                Description:     description,
                CreatedAt:       createdAt,
                Enabled:         true,
        }, nil</span>
}

// GetAPIKey 获取API密钥（不返回SecretKey）
func (m *MetadataStore) GetAPIKey(accessKeyID string) (*APIKey, error) <span class="cov8" title="1">{
        var key APIKey
        err := m.db.QueryRow(`
                SELECT access_key_id, description, created_at, enabled
                FROM api_keys WHERE access_key_id = ?`, accessKeyID,
        ).Scan(&amp;key.AccessKeyID, &amp;key.Description, &amp;key.CreatedAt, &amp;key.Enabled)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;key, err</span>
}

// ListAPIKeys 列出所有API密钥（不返回SecretKey）
func (m *MetadataStore) ListAPIKeys() ([]APIKey, error) <span class="cov8" title="1">{
        rows, err := m.db.Query(`
                SELECT access_key_id, description, created_at, enabled
                FROM api_keys ORDER BY created_at DESC`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var keys []APIKey
        for rows.Next() </span><span class="cov8" title="1">{
                var key APIKey
                if err := rows.Scan(&amp;key.AccessKeyID, &amp;key.Description, &amp;key.CreatedAt, &amp;key.Enabled); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">keys = append(keys, key)</span>
        }
        <span class="cov8" title="1">return keys, nil</span>
}

// ListAPIKeysWithPermissions 列出所有API密钥及其权限（内部使用，包含SecretKey，自动解密）
func (m *MetadataStore) ListAPIKeysWithPermissions() ([]APIKeyWithPermissions, error) <span class="cov8" title="1">{
        // 使用事务确保读取一致性
        tx, err := m.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        rows, err := tx.Query(`
                SELECT access_key_id, secret_access_key, description, created_at, enabled
                FROM api_keys ORDER BY created_at DESC`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var keys []APIKeyWithPermissions
        for rows.Next() </span><span class="cov8" title="1">{
                var key APIKeyWithPermissions
                var encryptedSecret string
                if err := rows.Scan(&amp;key.AccessKeyID, &amp;encryptedSecret, &amp;key.Description, &amp;key.CreatedAt, &amp;key.Enabled); err != nil </span><span class="cov0" title="0">{
                        rows.Close()
                        return nil, err
                }</span>
                // 解密 SecretKey
                <span class="cov8" title="1">key.SecretAccessKey, err = m.DecryptSecret(encryptedSecret)
                if err != nil </span><span class="cov0" title="0">{
                        rows.Close()
                        return nil, err
                }</span>
                <span class="cov8" title="1">keys = append(keys, key)</span>
        }
        <span class="cov8" title="1">rows.Close()

        // 获取每个密钥的权限（在同一事务中）
        for i := range keys </span><span class="cov8" title="1">{
                permRows, err := tx.Query(`
                        SELECT access_key_id, bucket_name, can_read, can_write
                        FROM api_key_permissions WHERE access_key_id = ?`, keys[i].AccessKeyID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for permRows.Next() </span><span class="cov8" title="1">{
                        var perm APIKeyPermission
                        if err := permRows.Scan(&amp;perm.AccessKeyID, &amp;perm.BucketName, &amp;perm.CanRead, &amp;perm.CanWrite); err != nil </span><span class="cov0" title="0">{
                                permRows.Close()
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">keys[i].Permissions = append(keys[i].Permissions, perm)</span>
                }
                <span class="cov8" title="1">permRows.Close()</span>
        }

        // 只读事务，不需要 Commit，Rollback 会自动释放
        <span class="cov8" title="1">return keys, nil</span>
}

// DeleteAPIKey 删除API密钥
func (m *MetadataStore) DeleteAPIKey(accessKeyID string) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec("DELETE FROM api_keys WHERE access_key_id = ?", accessKeyID)
                return err
        }</span>)
}

// UpdateAPIKeyEnabled 启用/禁用API密钥
func (m *MetadataStore) UpdateAPIKeyEnabled(accessKeyID string, enabled bool) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec("UPDATE api_keys SET enabled = ? WHERE access_key_id = ?", enabled, accessKeyID)
                return err
        }</span>)
}

// UpdateAPIKeyDescription 更新API密钥描述
func (m *MetadataStore) UpdateAPIKeyDescription(accessKeyID, description string) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec("UPDATE api_keys SET description = ? WHERE access_key_id = ?", description, accessKeyID)
                return err
        }</span>)
}

// ResetAPIKeySecret 重置API密钥的SecretKey（加密存储）
func (m *MetadataStore) ResetAPIKeySecret(accessKeyID string) (string, error) <span class="cov8" title="1">{
        newSecret := generateRandomKey(40)

        // 加密 SecretKey
        encryptedSecret, err := m.EncryptSecret(newSecret)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var rows int64
        err = m.withWriteLock(func() error </span><span class="cov8" title="1">{
                result, err := m.db.Exec("UPDATE api_keys SET secret_access_key = ? WHERE access_key_id = ?", encryptedSecret, accessKeyID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">rows, _ = result.RowsAffected()
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if rows == 0 </span><span class="cov8" title="1">{
                return "", sql.ErrNoRows
        }</span>
        <span class="cov8" title="1">return newSecret, nil</span> // 返回明文给用户
}

// === API Key Permission 操作 ===

// SetAPIKeyPermission 设置API密钥的桶权限
func (m *MetadataStore) SetAPIKeyPermission(perm *APIKeyPermission) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(`
                        INSERT OR REPLACE INTO api_key_permissions (access_key_id, bucket_name, can_read, can_write)
                        VALUES (?, ?, ?, ?)`,
                        perm.AccessKeyID, perm.BucketName, perm.CanRead, perm.CanWrite,
                )
                return err
        }</span>)
}

// DeleteAPIKeyPermission 删除API密钥的桶权限
func (m *MetadataStore) DeleteAPIKeyPermission(accessKeyID, bucketName string) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(
                        "DELETE FROM api_key_permissions WHERE access_key_id = ? AND bucket_name = ?",
                        accessKeyID, bucketName,
                )
                return err
        }</span>)
}

// GetAPIKeyPermissions 获取API密钥的所有权限
func (m *MetadataStore) GetAPIKeyPermissions(accessKeyID string) ([]APIKeyPermission, error) <span class="cov8" title="1">{
        rows, err := m.db.Query(`
                SELECT access_key_id, bucket_name, can_read, can_write
                FROM api_key_permissions WHERE access_key_id = ?`, accessKeyID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var perms []APIKeyPermission
        for rows.Next() </span><span class="cov8" title="1">{
                var perm APIKeyPermission
                if err := rows.Scan(&amp;perm.AccessKeyID, &amp;perm.BucketName, &amp;perm.CanRead, &amp;perm.CanWrite); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">perms = append(perms, perm)</span>
        }
        <span class="cov8" title="1">return perms, nil</span>
}

// generateRandomKey 生成随机密钥
func generateRandomKey(length int) string <span class="cov8" title="1">{
        bytes := make([]byte, length/2)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // crypto/rand 不可用是严重错误，应立即终止
                panic("crypto/rand unavailable: " + err.Error())</span>
        }
        <span class="cov8" title="1">return hex.EncodeToString(bytes)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package storage

import (
        "database/sql"
        "time"
)

// AuditAction 审计操作类型
type AuditAction string

const (
        // 认证相关
        AuditActionLogin         AuditAction = "login"          // 登录
        AuditActionLoginFailed   AuditAction = "login_failed"   // 登录失败
        AuditActionLogout        AuditAction = "logout"         // 登出
        AuditActionPasswordReset AuditAction = "password_reset" // 重置密码

        // 系统相关
        AuditActionSystemInstall  AuditAction = "system_install"  // 系统安装
        AuditActionSettingsUpdate AuditAction = "settings_update" // 更新系统设置
        AuditActionPasswordChange AuditAction = "password_change" // 修改密码

        // Bucket 相关
        AuditActionBucketCreate     AuditAction = "bucket_create"      // 创建桶
        AuditActionBucketDelete     AuditAction = "bucket_delete"      // 删除桶
        AuditActionBucketSetPublic  AuditAction = "bucket_set_public"  // 设置桶公开
        AuditActionBucketSetPrivate AuditAction = "bucket_set_private" // 设置桶私有

        // 对象相关
        AuditActionObjectUpload AuditAction = "object_upload" // 上传对象
        AuditActionObjectDelete AuditAction = "object_delete" // 删除对象
        AuditActionObjectCopy   AuditAction = "object_copy"   // 复制对象
        AuditActionBatchDelete  AuditAction = "batch_delete"  // 批量删除

        // API Key 相关
        AuditActionAPIKeyCreate      AuditAction = "apikey_create"       // 创建 API Key
        AuditActionAPIKeyDelete      AuditAction = "apikey_delete"       // 删除 API Key
        AuditActionAPIKeyResetSecret AuditAction = "apikey_reset_secret" // 重置 Secret
        AuditActionAPIKeyUpdate      AuditAction = "apikey_update"       // 更新 API Key
        AuditActionAPIKeySetPerm     AuditAction = "apikey_set_perm"     // 设置权限
        AuditActionAPIKeyDelPerm     AuditAction = "apikey_del_perm"     // 删除权限

        // 迁移相关
        AuditActionMigrateCreate AuditAction = "migrate_create" // 创建迁移任务
        AuditActionMigrateCancel AuditAction = "migrate_cancel" // 取消迁移任务
)

// AuditLog 审计日志
type AuditLog struct {
        ID        int64       `json:"id"`
        Timestamp time.Time   `json:"timestamp"`
        Action    AuditAction `json:"action"`
        Actor     string      `json:"actor"`      // 操作者（用户名或 API Key ID）
        IP        string      `json:"ip"`         // 客户端 IP
        Resource  string      `json:"resource"`   // 资源（桶名、对象键等）
        Detail    string      `json:"detail"`     // 详细信息（JSON 格式）
        Success   bool        `json:"success"`    // 是否成功
        UserAgent string      `json:"user_agent"` // 客户端 User-Agent
}

// initAuditTable 初始化审计日志表
func (m *MetadataStore) initAuditTable() error <span class="cov8" title="1">{
        schema := `CREATE TABLE IF NOT EXISTS audit_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                action TEXT NOT NULL,
                actor TEXT NOT NULL DEFAULT '',
                ip TEXT NOT NULL DEFAULT '',
                resource TEXT NOT NULL DEFAULT '',
                detail TEXT NOT NULL DEFAULT '',
                success INTEGER NOT NULL DEFAULT 1,
                user_agent TEXT NOT NULL DEFAULT ''
        )`
        if _, err := m.db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 创建索引
        <span class="cov8" title="1">indexes := []string{
                `CREATE INDEX IF NOT EXISTS idx_audit_timestamp ON audit_logs(timestamp)`,
                `CREATE INDEX IF NOT EXISTS idx_audit_action ON audit_logs(action)`,
                `CREATE INDEX IF NOT EXISTS idx_audit_actor ON audit_logs(actor)`,
                `CREATE INDEX IF NOT EXISTS idx_audit_ip ON audit_logs(ip)`,
        }
        for _, idx := range indexes </span><span class="cov8" title="1">{
                if _, err := m.db.Exec(idx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// WriteAuditLog 写入审计日志
func (m *MetadataStore) WriteAuditLog(log *AuditLog) error <span class="cov8" title="1">{
        if log.Timestamp.IsZero() </span><span class="cov8" title="1">{
                log.Timestamp = time.Now().UTC()
        }</span>

        <span class="cov8" title="1">successInt := 0
        if log.Success </span><span class="cov8" title="1">{
                successInt = 1
        }</span>

        <span class="cov8" title="1">return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(`
                        INSERT INTO audit_logs (timestamp, action, actor, ip, resource, detail, success, user_agent)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
                        log.Timestamp, log.Action, log.Actor, log.IP, log.Resource, log.Detail, successInt, log.UserAgent,
                )
                return err
        }</span>)
}

// AuditLogQuery 审计日志查询参数
type AuditLogQuery struct {
        Action    AuditAction // 操作类型（可选）
        Actor     string      // 操作者（可选）
        IP        string      // IP 地址（可选）
        Resource  string      // 资源（可选）
        StartTime *time.Time  // 开始时间（可选）
        EndTime   *time.Time  // 结束时间（可选）
        Success   *bool       // 是否成功（可选）
        Limit     int         // 返回数量限制
        Offset    int         // 偏移量
}

// QueryAuditLogs 查询审计日志
func (m *MetadataStore) QueryAuditLogs(query *AuditLogQuery) ([]AuditLog, int, error) <span class="cov8" title="1">{
        // 构建查询条件
        conditions := []string{}
        args := []interface{}{}

        if query.Action != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "action = ?")
                args = append(args, query.Action)
        }</span>
        <span class="cov8" title="1">if query.Actor != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "actor LIKE ?")
                args = append(args, "%"+query.Actor+"%")
        }</span>
        <span class="cov8" title="1">if query.IP != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "ip LIKE ?")
                args = append(args, "%"+query.IP+"%")
        }</span>
        <span class="cov8" title="1">if query.Resource != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "resource LIKE ?")
                args = append(args, "%"+query.Resource+"%")
        }</span>
        <span class="cov8" title="1">if query.StartTime != nil </span><span class="cov8" title="1">{
                conditions = append(conditions, "timestamp &gt;= ?")
                args = append(args, *query.StartTime)
        }</span>
        <span class="cov8" title="1">if query.EndTime != nil </span><span class="cov8" title="1">{
                conditions = append(conditions, "timestamp &lt;= ?")
                args = append(args, *query.EndTime)
        }</span>
        <span class="cov8" title="1">if query.Success != nil </span><span class="cov8" title="1">{
                successInt := 0
                if *query.Success </span><span class="cov8" title="1">{
                        successInt = 1
                }</span>
                <span class="cov8" title="1">conditions = append(conditions, "success = ?")
                args = append(args, successInt)</span>
        }

        <span class="cov8" title="1">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                whereClause = "WHERE "
                for i, cond := range conditions </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                whereClause += " AND "
                        }</span>
                        <span class="cov8" title="1">whereClause += cond</span>
                }
        }

        // 查询总数
        <span class="cov8" title="1">var total int
        countSQL := "SELECT COUNT(*) FROM audit_logs " + whereClause
        if err := m.db.QueryRow(countSQL, args...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 查询数据
        <span class="cov8" title="1">if query.Limit &lt;= 0 </span><span class="cov8" title="1">{
                query.Limit = 100
        }</span>
        <span class="cov8" title="1">if query.Limit &gt; 1000 </span><span class="cov8" title="1">{
                query.Limit = 1000
        }</span>

        <span class="cov8" title="1">dataSQL := "SELECT id, timestamp, action, actor, ip, resource, detail, success, user_agent FROM audit_logs " +
                whereClause + " ORDER BY timestamp DESC LIMIT ? OFFSET ?"
        args = append(args, query.Limit, query.Offset)

        rows, err := m.db.Query(dataSQL, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var logs []AuditLog
        for rows.Next() </span><span class="cov8" title="1">{
                var log AuditLog
                var successInt int
                if err := rows.Scan(&amp;log.ID, &amp;log.Timestamp, &amp;log.Action, &amp;log.Actor, &amp;log.IP,
                        &amp;log.Resource, &amp;log.Detail, &amp;successInt, &amp;log.UserAgent); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov8" title="1">log.Success = successInt == 1
                logs = append(logs, log)</span>
        }

        <span class="cov8" title="1">return logs, total, nil</span>
}

// GetRecentAuditLogs 获取最近的审计日志
func (m *MetadataStore) GetRecentAuditLogs(limit int) ([]AuditLog, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                limit = 50
        }</span>

        <span class="cov8" title="1">rows, err := m.db.Query(`
                SELECT id, timestamp, action, actor, ip, resource, detail, success, user_agent
                FROM audit_logs ORDER BY timestamp DESC LIMIT ?`, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var logs []AuditLog
        for rows.Next() </span><span class="cov8" title="1">{
                var log AuditLog
                var successInt int
                if err := rows.Scan(&amp;log.ID, &amp;log.Timestamp, &amp;log.Action, &amp;log.Actor, &amp;log.IP,
                        &amp;log.Resource, &amp;log.Detail, &amp;successInt, &amp;log.UserAgent); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">log.Success = successInt == 1
                logs = append(logs, log)</span>
        }

        <span class="cov8" title="1">return logs, nil</span>
}

// CleanOldAuditLogs 清理旧的审计日志
func (m *MetadataStore) CleanOldAuditLogs(beforeDays int) (int64, error) <span class="cov8" title="1">{
        if beforeDays &lt;= 0 </span><span class="cov8" title="1">{
                beforeDays = 90 // 默认保留 90 天
        }</span>

        <span class="cov8" title="1">cutoff := time.Now().AddDate(0, 0, -beforeDays)
        var affected int64
        err := m.withWriteLock(func() error </span><span class="cov8" title="1">{
                result, err := m.db.Exec("DELETE FROM audit_logs WHERE timestamp &lt; ?", cutoff)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">affected, _ = result.RowsAffected()
                return nil</span>
        })
        <span class="cov8" title="1">return affected, err</span>
}

// GetAuditStats 获取审计统计
func (m *MetadataStore) GetAuditStats() (map[string]interface{}, error) <span class="cov8" title="1">{
        stats := make(map[string]interface{})

        // 总数
        var total int
        if err := m.db.QueryRow("SELECT COUNT(*) FROM audit_logs").Scan(&amp;total); err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">stats["total"] = total

        // 今日数量
        today := time.Now().Truncate(24 * time.Hour)
        var todayCount int
        if err := m.db.QueryRow("SELECT COUNT(*) FROM audit_logs WHERE timestamp &gt;= ?", today).Scan(&amp;todayCount); err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">stats["today"] = todayCount

        // 失败数量
        var failedCount int
        if err := m.db.QueryRow("SELECT COUNT(*) FROM audit_logs WHERE success = 0").Scan(&amp;failedCount); err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">stats["failed"] = failedCount

        // 按操作类型统计
        rows, err := m.db.Query("SELECT action, COUNT(*) FROM audit_logs GROUP BY action ORDER BY COUNT(*) DESC LIMIT 10")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        actionStats := make(map[string]int)
        for rows.Next() </span><span class="cov8" title="1">{
                var action string
                var count int
                if err := rows.Scan(&amp;action, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">actionStats[action] = count</span>
        }
        <span class="cov8" title="1">stats["by_action"] = actionStats

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package storage

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "io"
)

// 加密相关常量
const (
        SettingEncryptionKey = "system.encryption_key"
)

// 加密相关错误
var (
        ErrCiphertextTooShort = errors.New("密文太短")
        ErrInvalidCiphertext  = errors.New("无效的密文")
)

// getOrCreateEncryptionKey 获取或创建加密密钥
func (m *MetadataStore) getOrCreateEncryptionKey() ([]byte, error) <span class="cov8" title="1">{
        keyHex, err := m.GetSetting(SettingEncryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if keyHex != "" </span><span class="cov8" title="1">{
                // 已存在，解码返回
                return hex.DecodeString(keyHex)
        }</span>

        // 生成新的 256 位密钥
        <span class="cov8" title="1">key := make([]byte, 32)
        if _, err := rand.Read(key); err != nil </span><span class="cov0" title="0">{
                panic("crypto/rand unavailable: " + err.Error())</span>
        }

        // 存储密钥
        <span class="cov8" title="1">if err := m.SetSetting(SettingEncryptionKey, hex.EncodeToString(key)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return key, nil</span>
}

// EncryptSecret 使用 AES-GCM 加密敏感数据
func (m *MetadataStore) EncryptSecret(plaintext string) (string, error) <span class="cov8" title="1">{
        key, err := m.getOrCreateEncryptionKey()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 生成随机 nonce
        <span class="cov8" title="1">nonce := make([]byte, aesGCM.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 加密
        <span class="cov8" title="1">ciphertext := aesGCM.Seal(nonce, nonce, []byte(plaintext), nil)

        // 返回 base64 编码的密文
        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

// DecryptSecret 使用 AES-GCM 解密敏感数据
func (m *MetadataStore) DecryptSecret(ciphertextB64 string) (string, error) <span class="cov8" title="1">{
        // 如果是明文（未加密的旧数据），直接返回
        // 加密数据一定是 base64 编码，长度会更长
        if len(ciphertextB64) &lt; 44 </span><span class="cov8" title="1">{
                // 可能是未加密的旧数据，直接返回
                return ciphertextB64, nil
        }</span>

        <span class="cov8" title="1">ciphertext, err := base64.StdEncoding.DecodeString(ciphertextB64)
        if err != nil </span><span class="cov8" title="1">{
                // 解码失败，可能是明文旧数据
                return ciphertextB64, nil
        }</span>

        <span class="cov8" title="1">key, err := m.getOrCreateEncryptionKey()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">nonceSize := aesGCM.NonceSize()
        if len(ciphertext) &lt; nonceSize </span><span class="cov0" title="0">{
                // 太短，可能是明文旧数据
                return ciphertextB64, nil
        }</span>

        <span class="cov8" title="1">nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
        plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                // 解密失败，可能是明文旧数据
                return ciphertextB64, nil
        }</span>

        <span class="cov8" title="1">return string(plaintext), nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package storage

import (
        "crypto/md5"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
)

// 安全错误定义
var (
        ErrInvalidPath = errors.New("invalid path: path traversal detected")
        ErrInvalidKey  = errors.New("invalid key: contains forbidden characters")
)

// FileStore 文件系统存储
type FileStore struct {
        basePath string
}

// NewFileStore 创建文件存储
func NewFileStore(basePath string) (*FileStore, error) <span class="cov8" title="1">{
        // 获取绝对路径
        absPath, err := filepath.Abs(basePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(absPath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;FileStore{basePath: absPath}, nil</span>
}

// validateKey 验证key是否安全（防止路径遍历攻击）
func validateKey(key string) error <span class="cov8" title="1">{
        // 禁止空key
        if key == "" </span><span class="cov8" title="1">{
                return ErrInvalidKey
        }</span>
        // 禁止包含..的路径遍历
        <span class="cov8" title="1">if strings.Contains(key, "..") </span><span class="cov8" title="1">{
                return ErrInvalidPath
        }</span>
        // 禁止绝对路径
        <span class="cov8" title="1">if strings.HasPrefix(key, "/") || strings.HasPrefix(key, "\\") </span><span class="cov8" title="1">{
                return ErrInvalidPath
        }</span>
        // 禁止包含空字节
        <span class="cov8" title="1">if strings.Contains(key, "\x00") </span><span class="cov8" title="1">{
                return ErrInvalidPath
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateBucket 验证bucket名称是否安全
func validateBucket(bucket string) error <span class="cov8" title="1">{
        if bucket == "" </span><span class="cov8" title="1">{
                return ErrInvalidKey
        }</span>
        // 禁止包含..的路径遍历
        <span class="cov8" title="1">if strings.Contains(bucket, "..") </span><span class="cov8" title="1">{
                return ErrInvalidPath
        }</span>
        // 禁止包含路径分隔符
        <span class="cov8" title="1">if strings.ContainsAny(bucket, "/\\") </span><span class="cov8" title="1">{
                return ErrInvalidPath
        }</span>
        // 禁止包含空字节
        <span class="cov8" title="1">if strings.Contains(bucket, "\x00") </span><span class="cov8" title="1">{
                return ErrInvalidPath
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// getPath 获取存储路径（内部使用，已验证安全性）
func (f *FileStore) getPath(bucket, key string) (string, error) <span class="cov8" title="1">{
        // 验证bucket和key的安全性
        if err := validateBucket(bucket); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if err := validateKey(key); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // 使用 key 的 hash 前两位作为子目录，避免单目录文件过多
        <span class="cov8" title="1">h := md5.Sum([]byte(key))
        subdir := hex.EncodeToString(h[:1])
        fullPath := filepath.Join(f.basePath, bucket, subdir, key)

        // 确保最终路径在basePath内（双重验证）
        cleanPath := filepath.Clean(fullPath)
        if !strings.HasPrefix(cleanPath, f.basePath) </span><span class="cov0" title="0">{
                return "", ErrInvalidPath
        }</span>

        <span class="cov8" title="1">return cleanPath, nil</span>
}

// getPartPath 获取分片存储路径
func (f *FileStore) getPartPath(uploadID string, partNumber int) (string, error) <span class="cov8" title="1">{
        // 验证uploadID安全性（只允许十六进制字符）
        for _, c := range uploadID </span><span class="cov8" title="1">{
                if !((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F')) </span><span class="cov8" title="1">{
                        return "", ErrInvalidPath
                }</span>
        }
        <span class="cov8" title="1">if partNumber &lt; 1 || partNumber &gt; 10000 </span><span class="cov8" title="1">{
                return "", ErrInvalidPath
        }</span>
        <span class="cov8" title="1">return filepath.Join(f.basePath, ".multipart", uploadID, fmt.Sprintf("%05d", partNumber)), nil</span>
}

// CreateBucket 创建存储桶目录
func (f *FileStore) CreateBucket(name string) error <span class="cov8" title="1">{
        if err := validateBucket(name); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return os.MkdirAll(filepath.Join(f.basePath, name), 0755)</span>
}

// DeleteBucket 删除存储桶目录
func (f *FileStore) DeleteBucket(name string) error <span class="cov8" title="1">{
        if err := validateBucket(name); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">bucketPath := filepath.Join(f.basePath, name)
        // 确保路径在basePath内
        cleanPath := filepath.Clean(bucketPath)
        if !strings.HasPrefix(cleanPath, f.basePath) </span><span class="cov0" title="0">{
                return ErrInvalidPath
        }</span>
        <span class="cov8" title="1">return os.RemoveAll(cleanPath)</span>
}

// PutObject 存储对象并返回 ETag
func (f *FileStore) PutObject(bucket, key string, reader io.Reader, size int64) (string, string, error) <span class="cov8" title="1">{
        path, err := f.getPath(bucket, key)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        // 确保目录存在
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // 同时计算 MD5
        hash := md5.New()
        writer := io.MultiWriter(file, hash)

        if _, err := io.Copy(writer, reader); err != nil </span><span class="cov0" title="0">{
                os.Remove(path)
                return "", "", err
        }</span>

        // 确保数据写入磁盘
        <span class="cov8" title="1">if err := file.Sync(); err != nil </span><span class="cov0" title="0">{
                os.Remove(path)
                return "", "", err
        }</span>

        <span class="cov8" title="1">etag := hex.EncodeToString(hash.Sum(nil))
        return path, etag, nil</span>
}

// GetObject 获取对象
func (f *FileStore) GetObject(storagePath string) (*os.File, error) <span class="cov8" title="1">{
        // 处理相对路径：如果不是以 basePath 开头，尝试将其转换为绝对路径
        cleanPath := filepath.Clean(storagePath)

        // 如果是相对路径，转换为绝对路径
        if !filepath.IsAbs(cleanPath) </span><span class="cov8" title="1">{
                // 获取当前工作目录
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">cleanPath = filepath.Join(cwd, cleanPath)</span>
        }

        // 验证路径在basePath内
        <span class="cov8" title="1">if !strings.HasPrefix(cleanPath, f.basePath) </span><span class="cov8" title="1">{
                return nil, ErrInvalidPath
        }</span>
        <span class="cov8" title="1">return os.Open(cleanPath)</span>
}

// DeleteObject 删除对象
func (f *FileStore) DeleteObject(storagePath string) error <span class="cov8" title="1">{
        // 处理相对路径：如果不是以 basePath 开头，尝试将其转换为绝对路径
        cleanPath := filepath.Clean(storagePath)

        // 如果是相对路径，转换为绝对路径
        if !filepath.IsAbs(cleanPath) </span><span class="cov8" title="1">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cleanPath = filepath.Join(cwd, cleanPath)</span>
        }

        // 验证路径在basePath内
        <span class="cov8" title="1">if !strings.HasPrefix(cleanPath, f.basePath) </span><span class="cov8" title="1">{
                return ErrInvalidPath
        }</span>
        <span class="cov8" title="1">return os.Remove(cleanPath)</span>
}

// CopyObject 复制对象到新位置
func (f *FileStore) CopyObject(srcStoragePath, destBucket, destKey string) (string, string, error) <span class="cov8" title="1">{
        // 处理相对路径：如果不是以 basePath 开头，尝试将其转换为绝对路径
        cleanSrcPath := filepath.Clean(srcStoragePath)

        // 如果是相对路径，转换为绝对路径
        if !filepath.IsAbs(cleanSrcPath) </span><span class="cov0" title="0">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>
                <span class="cov0" title="0">cleanSrcPath = filepath.Join(cwd, cleanSrcPath)</span>
        }

        // 验证源路径在basePath内
        <span class="cov8" title="1">if !strings.HasPrefix(cleanSrcPath, f.basePath) </span><span class="cov0" title="0">{
                return "", "", ErrInvalidPath
        }</span>

        // 打开源文件
        <span class="cov8" title="1">srcFile, err := os.Open(cleanSrcPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">defer srcFile.Close()

        // 获取目标路径
        destPath, err := f.getPath(destBucket, destKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        // 确保目标目录存在
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(destPath), 0755); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // 创建目标文件
        <span class="cov8" title="1">destFile, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">defer destFile.Close()

        // 同时计算 MD5
        hash := md5.New()
        writer := io.MultiWriter(destFile, hash)

        if _, err := io.Copy(writer, srcFile); err != nil </span><span class="cov0" title="0">{
                os.Remove(destPath)
                return "", "", err
        }</span>

        // 确保数据写入磁盘
        <span class="cov8" title="1">if err := destFile.Sync(); err != nil </span><span class="cov0" title="0">{
                os.Remove(destPath)
                return "", "", err
        }</span>

        <span class="cov8" title="1">etag := hex.EncodeToString(hash.Sum(nil))
        return destPath, etag, nil</span>
}

// PutPart 存储分片
func (f *FileStore) PutPart(uploadID string, partNumber int, reader io.Reader) (string, int64, error) <span class="cov8" title="1">{
        path, err := f.getPartPath(uploadID, partNumber)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov8" title="1">file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hash := md5.New()
        writer := io.MultiWriter(file, hash)

        size, err := io.Copy(writer, reader)
        if err != nil </span><span class="cov0" title="0">{
                os.Remove(path)
                return "", 0, err
        }</span>

        // 确保数据写入磁盘
        <span class="cov8" title="1">if err := file.Sync(); err != nil </span><span class="cov0" title="0">{
                os.Remove(path)
                return "", 0, err
        }</span>

        <span class="cov8" title="1">etag := hex.EncodeToString(hash.Sum(nil))
        return etag, size, nil</span>
}

// MergeParts 合并分片
func (f *FileStore) MergeParts(bucket, key, uploadID string, partNumbers []int) (string, int64, error) <span class="cov8" title="1">{
        path, err := f.getPath(bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov8" title="1">outFile, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>
        <span class="cov8" title="1">defer outFile.Close()

        hash := md5.New()
        writer := io.MultiWriter(outFile, hash)
        var totalSize int64

        for _, partNum := range partNumbers </span><span class="cov8" title="1">{
                partPath, err := f.getPartPath(uploadID, partNum)
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, err
                }</span>
                <span class="cov8" title="1">partFile, err := os.Open(partPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, err
                }</span>

                <span class="cov8" title="1">n, err := io.Copy(writer, partFile)
                partFile.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, err
                }</span>
                <span class="cov8" title="1">totalSize += n</span>
        }

        // 确保数据写入磁盘
        <span class="cov8" title="1">if err := outFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        // 清理分片目录
        <span class="cov8" title="1">os.RemoveAll(filepath.Join(f.basePath, ".multipart", uploadID))

        etag := hex.EncodeToString(hash.Sum(nil))
        return etag, totalSize, nil</span>
}

// AbortMultipartUpload 清理分片
func (f *FileStore) AbortMultipartUpload(uploadID string) error <span class="cov8" title="1">{
        // 验证uploadID安全性
        for _, c := range uploadID </span><span class="cov8" title="1">{
                if !((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F')) </span><span class="cov8" title="1">{
                        return ErrInvalidPath
                }</span>
        }
        <span class="cov8" title="1">return os.RemoveAll(filepath.Join(f.basePath, ".multipart", uploadID))</span>
}

// GetStoragePath 获取对象存储路径
func (f *FileStore) GetStoragePath(bucket, key string) string <span class="cov8" title="1">{
        path, err := f.getPath(bucket, key)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return path</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package storage

import (
        "crypto/md5"
        "encoding/hex"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// GCResult 垃圾回收结果
type GCResult struct {
        OrphanFiles     []OrphanFile `json:"orphan_files"`      // 孤立文件列表
        OrphanCount     int          `json:"orphan_count"`      // 孤立文件数量
        OrphanSize      int64        `json:"orphan_size"`       // 孤立文件总大小
        ExpiredUploads  []string     `json:"expired_uploads"`   // 过期的分片上传ID
        ExpiredCount    int          `json:"expired_count"`     // 过期上传数量
        ExpiredPartSize int64        `json:"expired_part_size"` // 过期分片总大小
        Cleaned         bool         `json:"cleaned"`           // 是否已清理
        CleanedAt       *time.Time   `json:"cleaned_at"`        // 清理时间
}

// OrphanFile 孤立文件信息
type OrphanFile struct {
        Path       string    `json:"path"`        // 相对路径
        Size       int64     `json:"size"`        // 文件大小
        ModifiedAt time.Time `json:"modified_at"` // 修改时间
}

// ExpiredUploadInfo 过期上传信息
type ExpiredUploadInfo struct {
        UploadID    string    `json:"upload_id"`
        Bucket      string    `json:"bucket"`
        Key         string    `json:"key"`
        Initiated   time.Time `json:"initiated"`
        ContentType string    `json:"content_type"`
        PartCount   int       `json:"part_count"`
        TotalSize   int64     `json:"total_size"`
}

// ScanOrphanFiles 扫描孤立文件（元数据中不存在但磁盘上存在的文件）
func (f *FileStore) ScanOrphanFiles(metadata *MetadataStore) (*GCResult, error) <span class="cov8" title="1">{
        result := &amp;GCResult{
                OrphanFiles:    make([]OrphanFile, 0),
                ExpiredUploads: make([]string, 0),
        }

        // 获取所有元数据中的存储路径
        knownPaths := make(map[string]bool)
        buckets, err := metadata.ListBuckets()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, bucket := range buckets </span><span class="cov8" title="1">{
                // 获取桶中所有对象
                objects, err := metadata.ListAllObjects(bucket.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, obj := range objects </span><span class="cov8" title="1">{
                        knownPaths[obj.StoragePath] = true
                }</span>
        }

        // 遍历磁盘文件
        <span class="cov8" title="1">err = filepath.Walk(f.basePath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // 忽略错误继续
                }</span>

                // 跳过目录
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        // 跳过 .multipart 目录（由 ScanExpiredUploads 处理）
                        if info.Name() == ".multipart" </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                // 检查文件是否在元数据中
                <span class="cov8" title="1">if !knownPaths[path] </span><span class="cov8" title="1">{
                        relPath, _ := filepath.Rel(f.basePath, path)
                        result.OrphanFiles = append(result.OrphanFiles, OrphanFile{
                                Path:       relPath,
                                Size:       info.Size(),
                                ModifiedAt: info.ModTime(),
                        })
                        result.OrphanSize += info.Size()
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result.OrphanCount = len(result.OrphanFiles)
        return result, nil</span>
}

// CleanOrphanFiles 清理孤立文件
func (f *FileStore) CleanOrphanFiles(files []OrphanFile) error <span class="cov8" title="1">{
        for _, file := range files </span><span class="cov8" title="1">{
                fullPath := filepath.Join(f.basePath, file.Path)

                // 安全检查：确保路径在 basePath 下
                cleanPath := filepath.Clean(fullPath)
                if !strings.HasPrefix(cleanPath, f.basePath) </span><span class="cov8" title="1">{
                        continue</span> // 跳过可疑路径
                }

                <span class="cov8" title="1">if err := os.Remove(cleanPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 尝试清理空目录
                <span class="cov8" title="1">dir := filepath.Dir(cleanPath)
                f.cleanEmptyDirs(dir)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// cleanEmptyDirs 递归清理空目录，直到 basePath
func (f *FileStore) cleanEmptyDirs(dir string) <span class="cov8" title="1">{
        for strings.HasPrefix(dir, f.basePath) &amp;&amp; dir != f.basePath </span><span class="cov8" title="1">{
                // 检查目录是否为空
                entries, err := os.ReadDir(dir)
                if err != nil || len(entries) &gt; 0 </span><span class="cov8" title="1">{
                        return
                }</span>

                // 删除空目录
                <span class="cov8" title="1">if err := os.Remove(dir); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // 继续检查父目录
                <span class="cov8" title="1">dir = filepath.Dir(dir)</span>
        }
}

// GetExpiredUploads 获取过期的分片上传
func (m *MetadataStore) GetExpiredUploads(maxAge time.Duration) ([]ExpiredUploadInfo, error) <span class="cov8" title="1">{
        cutoff := time.Now().Add(-maxAge)

        rows, err := m.db.Query(`
                SELECT mu.upload_id, mu.bucket, mu.key, mu.initiated, mu.content_type,
                       COUNT(p.part_number) as part_count,
                       COALESCE(SUM(p.size), 0) as total_size
                FROM multipart_uploads mu
                LEFT JOIN parts p ON mu.upload_id = p.upload_id
                WHERE mu.initiated &lt; ?
                GROUP BY mu.upload_id
                ORDER BY mu.initiated
        `, cutoff)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var uploads []ExpiredUploadInfo
        for rows.Next() </span><span class="cov8" title="1">{
                var u ExpiredUploadInfo
                if err := rows.Scan(&amp;u.UploadID, &amp;u.Bucket, &amp;u.Key, &amp;u.Initiated,
                        &amp;u.ContentType, &amp;u.PartCount, &amp;u.TotalSize); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">uploads = append(uploads, u)</span>
        }

        <span class="cov8" title="1">return uploads, nil</span>
}

// CleanExpiredUploads 清理过期的分片上传
func (m *MetadataStore) CleanExpiredUploads(uploadIDs []string, filestore *FileStore) (int64, error) <span class="cov8" title="1">{
        var totalCleaned int64

        for _, uploadID := range uploadIDs </span><span class="cov8" title="1">{
                // 计算分片大小
                var partSize int64
                m.db.QueryRow("SELECT COALESCE(SUM(size), 0) FROM parts WHERE upload_id = ?", uploadID).Scan(&amp;partSize)
                totalCleaned += partSize

                // 删除分片记录
                if _, err := m.db.Exec("DELETE FROM parts WHERE upload_id = ?", uploadID); err != nil </span><span class="cov0" title="0">{
                        return totalCleaned, err
                }</span>

                // 删除上传记录
                <span class="cov8" title="1">if _, err := m.db.Exec("DELETE FROM multipart_uploads WHERE upload_id = ?", uploadID); err != nil </span><span class="cov0" title="0">{
                        return totalCleaned, err
                }</span>

                // 删除磁盘上的分片文件
                <span class="cov8" title="1">if filestore != nil </span><span class="cov8" title="1">{
                        filestore.AbortMultipartUpload(uploadID)
                }</span>
        }

        <span class="cov8" title="1">return totalCleaned, nil</span>
}

// ListAllObjects 列出桶中所有对象（无分页限制，内部使用）
func (m *MetadataStore) ListAllObjects(bucket string) ([]Object, error) <span class="cov8" title="1">{
        rows, err := m.db.Query(`
                SELECT bucket, key, size, etag, content_type, last_modified, storage_path
                FROM objects
                WHERE bucket = ?
                ORDER BY key
        `, bucket)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var objects []Object
        for rows.Next() </span><span class="cov8" title="1">{
                var obj Object
                if err := rows.Scan(&amp;obj.Bucket, &amp;obj.Key, &amp;obj.Size, &amp;obj.ETag,
                        &amp;obj.ContentType, &amp;obj.LastModified, &amp;obj.StoragePath); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">objects = append(objects, obj)</span>
        }

        <span class="cov8" title="1">return objects, nil</span>
}

// ScanMultipartOrphans 扫描 .multipart 目录中的孤立分片
func (f *FileStore) ScanMultipartOrphans(metadata *MetadataStore) ([]OrphanFile, int64, error) <span class="cov8" title="1">{
        multipartDir := filepath.Join(f.basePath, ".multipart")

        // 检查目录是否存在
        if _, err := os.Stat(multipartDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, 0, nil
        }</span>

        // 获取所有活跃的上传ID
        <span class="cov8" title="1">activeUploads := make(map[string]bool)
        rows, err := metadata.db.Query("SELECT upload_id FROM multipart_uploads")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var uploadID string
                if err := rows.Scan(&amp;uploadID); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov8" title="1">activeUploads[uploadID] = true</span>
        }

        <span class="cov8" title="1">var orphans []OrphanFile
        var totalSize int64

        // 遍历 .multipart 目录
        entries, err := os.ReadDir(multipartDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">uploadID := entry.Name()
                if activeUploads[uploadID] </span><span class="cov8" title="1">{
                        continue</span> // 活跃上传，跳过
                }

                // 计算孤立上传目录的大小
                <span class="cov8" title="1">uploadDir := filepath.Join(multipartDir, uploadID)
                err := filepath.Walk(uploadDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if err != nil || info.IsDir() </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">relPath, _ := filepath.Rel(f.basePath, path)
                        orphans = append(orphans, OrphanFile{
                                Path:       relPath,
                                Size:       info.Size(),
                                ModifiedAt: info.ModTime(),
                        })
                        totalSize += info.Size()
                        return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
        }

        <span class="cov8" title="1">return orphans, totalSize, nil</span>
}

// RunGC 执行完整的垃圾回收
func RunGC(filestore *FileStore, metadata *MetadataStore, maxUploadAge time.Duration, dryRun bool) (*GCResult, error) <span class="cov8" title="1">{
        result := &amp;GCResult{
                OrphanFiles:    make([]OrphanFile, 0),
                ExpiredUploads: make([]string, 0),
        }

        // 1. 扫描孤立文件
        orphanResult, err := filestore.ScanOrphanFiles(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result.OrphanFiles = orphanResult.OrphanFiles
        result.OrphanCount = orphanResult.OrphanCount
        result.OrphanSize = orphanResult.OrphanSize

        // 2. 扫描 .multipart 中的孤立分片
        multipartOrphans, multipartSize, err := filestore.ScanMultipartOrphans(metadata)
        if err == nil &amp;&amp; len(multipartOrphans) &gt; 0 </span><span class="cov0" title="0">{
                result.OrphanFiles = append(result.OrphanFiles, multipartOrphans...)
                result.OrphanCount += len(multipartOrphans)
                result.OrphanSize += multipartSize
        }</span>

        // 3. 扫描过期上传
        <span class="cov8" title="1">expiredUploads, err := metadata.GetExpiredUploads(maxUploadAge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, u := range expiredUploads </span><span class="cov8" title="1">{
                result.ExpiredUploads = append(result.ExpiredUploads, u.UploadID)
                result.ExpiredPartSize += u.TotalSize
        }</span>
        <span class="cov8" title="1">result.ExpiredCount = len(expiredUploads)

        // 如果不是干运行模式，执行清理
        if !dryRun </span><span class="cov8" title="1">{
                // 清理孤立文件
                if len(result.OrphanFiles) &gt; 0 </span><span class="cov8" title="1">{
                        if err := filestore.CleanOrphanFiles(result.OrphanFiles); err != nil </span><span class="cov0" title="0">{
                                return result, err
                        }</span>
                }

                // 清理过期上传
                <span class="cov8" title="1">if len(result.ExpiredUploads) &gt; 0 </span><span class="cov8" title="1">{
                        if _, err := metadata.CleanExpiredUploads(result.ExpiredUploads, filestore); err != nil </span><span class="cov0" title="0">{
                                return result, err
                        }</span>
                }

                <span class="cov8" title="1">result.Cleaned = true
                now := time.Now()
                result.CleanedAt = &amp;now</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// GetStoragePathFromKey 根据 bucket 和 key 计算预期的存储路径
func (f *FileStore) GetStoragePathFromKey(bucket, key string) string <span class="cov8" title="1">{
        h := md5.Sum([]byte(key))
        subdir := hex.EncodeToString(h[:1])
        return filepath.Join(f.basePath, bucket, subdir, key)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package storage

import (
        "crypto/md5"
        "encoding/hex"
        "fmt"
        "io"
        "os"
        "time"
)

// IntegrityIssue 完整性问题
type IntegrityIssue struct {
        Bucket     string `json:"bucket"`
        Key        string `json:"key"`
        IssueType  string `json:"issue_type"`  // missing_file, etag_mismatch, path_mismatch
        Expected   string `json:"expected"`    // 预期值
        Actual     string `json:"actual"`      // 实际值
        Size       int64  `json:"size"`        // 文件大小
        Repairable bool   `json:"repairable"` // 是否可修复
}

// IntegrityResult 完整性检查结果
type IntegrityResult struct {
        TotalChecked   int              `json:"total_checked"`    // 检查的对象总数
        IssuesFound    int              `json:"issues_found"`     // 发现的问题数
        Issues         []IntegrityIssue `json:"issues"`           // 问题列表
        MissingFiles   int              `json:"missing_files"`    // 缺失文件数
        EtagMismatches int              `json:"etag_mismatches"`  // ETag 不匹配数
        PathMismatches int              `json:"path_mismatches"`  // 路径不匹配数
        CheckedAt      time.Time        `json:"checked_at"`       // 检查时间
        Duration       float64          `json:"duration"`         // 检查耗时（秒）
        Repaired       bool             `json:"repaired"`         // 是否已修复
        RepairedCount  int              `json:"repaired_count"`   // 修复数量
}

// CheckIntegrity 检查数据完整性
func CheckIntegrity(filestore *FileStore, metadata *MetadataStore, verifyEtag bool, limit int) (*IntegrityResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        result := &amp;IntegrityResult{
                Issues:    make([]IntegrityIssue, 0),
                CheckedAt: startTime,
        }

        // 获取所有桶
        buckets, err := metadata.ListBuckets()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">checked := 0
        for _, bucket := range buckets </span><span class="cov8" title="1">{
                // 获取桶中所有对象
                objects, err := metadata.ListAllObjects(bucket.Name)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, obj := range objects </span><span class="cov8" title="1">{
                        // 检查文件是否存在
                        if _, err := os.Stat(obj.StoragePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                                issue := IntegrityIssue{
                                        Bucket:     obj.Bucket,
                                        Key:        obj.Key,
                                        IssueType:  "missing_file",
                                        Expected:   obj.StoragePath,
                                        Actual:     "not found",
                                        Size:       obj.Size,
                                        Repairable: true, // 可以删除元数据记录
                                }
                                result.Issues = append(result.Issues, issue)
                                result.MissingFiles++
                                result.IssuesFound++
                        }</span> else<span class="cov8" title="1"> if verifyEtag </span><span class="cov8" title="1">{
                                // 验证 ETag
                                actualEtag, err := calculateFileEtag(obj.StoragePath)
                                if err == nil &amp;&amp; actualEtag != obj.ETag </span><span class="cov8" title="1">{
                                        // 去掉引号比较
                                        expectedEtag := trimQuotes(obj.ETag)
                                        if actualEtag != expectedEtag </span><span class="cov8" title="1">{
                                                issue := IntegrityIssue{
                                                        Bucket:     obj.Bucket,
                                                        Key:        obj.Key,
                                                        IssueType:  "etag_mismatch",
                                                        Expected:   obj.ETag,
                                                        Actual:     actualEtag,
                                                        Size:       obj.Size,
                                                        Repairable: true, // 可以更新 ETag
                                                }
                                                result.Issues = append(result.Issues, issue)
                                                result.EtagMismatches++
                                                result.IssuesFound++
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">checked++
                        result.TotalChecked = checked

                        // 限制检查数量
                        if limit &gt; 0 &amp;&amp; checked &gt;= limit </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                <span class="cov8" title="1">if limit &gt; 0 &amp;&amp; checked &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">result.Duration = time.Since(startTime).Seconds()
        return result, nil</span>
}

// RepairIntegrity 修复完整性问题
func RepairIntegrity(filestore *FileStore, metadata *MetadataStore, issues []IntegrityIssue) (*IntegrityResult, error) <span class="cov8" title="1">{
        result := &amp;IntegrityResult{
                Issues:    make([]IntegrityIssue, 0),
                CheckedAt: time.Now(),
        }

        for _, issue := range issues </span><span class="cov8" title="1">{
                if !issue.Repairable </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">switch issue.IssueType </span>{
                case "missing_file":<span class="cov8" title="1">
                        // 删除元数据记录
                        if err := metadata.DeleteObject(issue.Bucket, issue.Key); err == nil </span><span class="cov8" title="1">{
                                result.RepairedCount++
                        }</span>
                case "etag_mismatch":<span class="cov8" title="1">
                        // 重新计算并更新 ETag
                        obj, err := metadata.GetObject(issue.Bucket, issue.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">newEtag, err := calculateFileEtag(obj.StoragePath)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // 更新 ETag
                        <span class="cov8" title="1">if err := metadata.UpdateObjectEtag(issue.Bucket, issue.Key, fmt.Sprintf("\"%s\"", newEtag)); err == nil </span><span class="cov8" title="1">{
                                result.RepairedCount++
                        }</span>
                }
        }

        <span class="cov8" title="1">result.Repaired = true
        return result, nil</span>
}

// calculateFileEtag 计算文件的 ETag (MD5)
func calculateFileEtag(path string) (string, error) <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hash := md5.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

// trimQuotes 去掉字符串两端的引号
func trimQuotes(s string) string <span class="cov8" title="1">{
        if len(s) &gt;= 2 &amp;&amp; s[0] == '"' &amp;&amp; s[len(s)-1] == '"' </span><span class="cov8" title="1">{
                return s[1 : len(s)-1]
        }</span>
        <span class="cov8" title="1">return s</span>
}

// UpdateObjectEtag 更新对象的 ETag
func (m *MetadataStore) UpdateObjectEtag(bucket, key, etag string) error <span class="cov8" title="1">{
        _, err := m.db.Exec(`
                UPDATE objects
                SET etag = ?
                WHERE bucket = ? AND key = ?
        `, etag, bucket, key)
        return err
}</span>

</pre>
		
		<pre class="file" id="file29" style="display: none">package storage

import (
        "database/sql"
        "fmt"
        "strings"
        "sync"
        "time"

        _ "github.com/mattn/go-sqlite3"
)

// MetadataStore SQLite元数据存储
type MetadataStore struct {
        db    *sql.DB
        wmu   sync.Mutex // 写操作互斥锁，确保写入串行化
}

// NewMetadataStore 创建元数据存储
func NewMetadataStore(dbPath string) (*MetadataStore, error) <span class="cov8" title="1">{
        // 使用 WAL 模式提升并发性能，设置 busy_timeout 避免锁等待
        db, err := sql.Open("sqlite3", dbPath+"?_journal_mode=WAL&amp;_busy_timeout=5000&amp;_synchronous=NORMAL&amp;_cache_size=2000")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 设置连接池参数（SQLite + WAL 模式优化）
        // WAL 模式允许：多个读取者 + 一个写入者 同时工作
        // 写操作通过应用层 wmu 互斥锁串行化
        <span class="cov8" title="1">db.SetMaxOpenConns(10)   // 允许多个并发读取
        db.SetMaxIdleConns(5)    // 保持空闲连接
        db.SetConnMaxLifetime(0) // 连接不过期
        db.SetConnMaxIdleTime(0) // 空闲连接不过期

        // 验证连接
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov8" title="1">store := &amp;MetadataStore{db: db}
        if err := store.initTables(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">return store, nil</span>
}

// initTables 初始化数据库表
func (m *MetadataStore) initTables() error <span class="cov8" title="1">{
        schemas := []string{
                `CREATE TABLE IF NOT EXISTS buckets (
                        name TEXT PRIMARY KEY,
                        creation_date DATETIME NOT NULL,
                        is_public INTEGER DEFAULT 0
                )`,
                `CREATE TABLE IF NOT EXISTS objects (
                        bucket TEXT NOT NULL,
                        key TEXT NOT NULL,
                        size INTEGER NOT NULL,
                        etag TEXT NOT NULL,
                        content_type TEXT,
                        last_modified DATETIME NOT NULL,
                        storage_path TEXT NOT NULL,
                        PRIMARY KEY (bucket, key),
                        FOREIGN KEY (bucket) REFERENCES buckets(name) ON DELETE CASCADE
                )`,
                `CREATE TABLE IF NOT EXISTS multipart_uploads (
                        upload_id TEXT PRIMARY KEY,
                        bucket TEXT NOT NULL,
                        key TEXT NOT NULL,
                        initiated DATETIME NOT NULL,
                        content_type TEXT,
                        FOREIGN KEY (bucket) REFERENCES buckets(name) ON DELETE CASCADE
                )`,
                `CREATE TABLE IF NOT EXISTS parts (
                        upload_id TEXT NOT NULL,
                        part_number INTEGER NOT NULL,
                        size INTEGER NOT NULL,
                        etag TEXT NOT NULL,
                        modified_at DATETIME NOT NULL,
                        PRIMARY KEY (upload_id, part_number),
                        FOREIGN KEY (upload_id) REFERENCES multipart_uploads(upload_id) ON DELETE CASCADE
                )`,
                `CREATE INDEX IF NOT EXISTS idx_objects_bucket ON objects(bucket)`,
                `CREATE INDEX IF NOT EXISTS idx_objects_prefix ON objects(bucket, key)`,
                // API Keys 表
                `CREATE TABLE IF NOT EXISTS api_keys (
                        access_key_id TEXT PRIMARY KEY,
                        secret_access_key TEXT NOT NULL,
                        description TEXT,
                        created_at DATETIME NOT NULL,
                        enabled INTEGER DEFAULT 1
                )`,
                // API Key 桶权限表
                `CREATE TABLE IF NOT EXISTS api_key_permissions (
                        access_key_id TEXT NOT NULL,
                        bucket_name TEXT NOT NULL,
                        can_read INTEGER DEFAULT 0,
                        can_write INTEGER DEFAULT 0,
                        PRIMARY KEY (access_key_id, bucket_name),
                        FOREIGN KEY (access_key_id) REFERENCES api_keys(access_key_id) ON DELETE CASCADE
                )`,
                `CREATE INDEX IF NOT EXISTS idx_api_key_permissions ON api_key_permissions(access_key_id)`,
                // 系统配置表
                `CREATE TABLE IF NOT EXISTS system_settings (
                        key TEXT PRIMARY KEY,
                        value TEXT NOT NULL,
                        updated_at DATETIME NOT NULL
                )`,
        }

        for _, schema := range schemas </span><span class="cov8" title="1">{
                if _, err := m.db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table: %w", err)
                }</span>
        }

        // 检查并添加is_public列（用于兼容现有数据）
        <span class="cov8" title="1">var columnExists bool
        err := m.db.QueryRow(`
                SELECT COUNT(*) &gt; 0
                FROM pragma_table_info('buckets')
                WHERE name = 'is_public'
        `).Scan(&amp;columnExists)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("check column failed: %v", err)
        }</span>

        <span class="cov8" title="1">if !columnExists </span><span class="cov0" title="0">{
                if _, err := m.db.Exec("ALTER TABLE buckets ADD COLUMN is_public INTEGER DEFAULT 0"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add is_public column failed: %v", err)
                }</span>
        }

        // 初始化审计日志表
        <span class="cov8" title="1">if err := m.initAuditTable(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("init audit table failed: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Close 关闭数据库连接
func (m *MetadataStore) Close() error <span class="cov8" title="1">{
        return m.db.Close()
}</span>

// withWriteLock 执行写操作（带互斥锁）
func (m *MetadataStore) withWriteLock(fn func() error) error <span class="cov8" title="1">{
        m.wmu.Lock()
        defer m.wmu.Unlock()
        return fn()
}</span>

// === Bucket 操作 ===

func (m *MetadataStore) CreateBucket(name string) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(
                        "INSERT INTO buckets (name, creation_date, is_public) VALUES (?, ?, ?)",
                        name, time.Now().UTC(), 0,
                )
                return err
        }</span>)
}

func (m *MetadataStore) DeleteBucket(name string) error <span class="cov8" title="1">{
        m.wmu.Lock()
        defer m.wmu.Unlock()

        // 使用事务确保检查和删除的原子性
        tx, err := m.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // 检查是否有对象
        var count int
        if err := tx.QueryRow("SELECT COUNT(*) FROM objects WHERE bucket = ?", name).Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("bucket not empty")
        }</span>

        // 删除桶
        <span class="cov8" title="1">if _, err := tx.Exec("DELETE FROM buckets WHERE name = ?", name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

func (m *MetadataStore) GetBucket(name string) (*Bucket, error) <span class="cov8" title="1">{
        var bucket Bucket
        err := m.db.QueryRow(
                "SELECT name, creation_date, is_public FROM buckets WHERE name = ?", name,
        ).Scan(&amp;bucket.Name, &amp;bucket.CreationDate, &amp;bucket.IsPublic)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;bucket, err</span>
}

func (m *MetadataStore) ListBuckets() ([]Bucket, error) <span class="cov8" title="1">{
        rows, err := m.db.Query("SELECT name, creation_date, is_public FROM buckets ORDER BY name")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var buckets []Bucket
        for rows.Next() </span><span class="cov8" title="1">{
                var b Bucket
                if err := rows.Scan(&amp;b.Name, &amp;b.CreationDate, &amp;b.IsPublic); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">buckets = append(buckets, b)</span>
        }
        <span class="cov8" title="1">return buckets, nil</span>
}

// UpdateBucketPublic 设置桶的公有/私有状态
func (m *MetadataStore) UpdateBucketPublic(name string, isPublic bool) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(
                        "UPDATE buckets SET is_public = ? WHERE name = ?",
                        isPublic, name,
                )
                return err
        }</span>)
}

// === Object 操作 ===

func (m *MetadataStore) PutObject(obj *Object) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(`
                        INSERT OR REPLACE INTO objects (bucket, key, size, etag, content_type, last_modified, storage_path)
                        VALUES (?, ?, ?, ?, ?, ?, ?)`,
                        obj.Bucket, obj.Key, obj.Size, obj.ETag, obj.ContentType, obj.LastModified, obj.StoragePath,
                )
                return err
        }</span>)
}

func (m *MetadataStore) GetObject(bucket, key string) (*Object, error) <span class="cov8" title="1">{
        var obj Object
        err := m.db.QueryRow(`
                SELECT bucket, key, size, etag, content_type, last_modified, storage_path
                FROM objects WHERE bucket = ? AND key = ?`,
                bucket, key,
        ).Scan(&amp;obj.Bucket, &amp;obj.Key, &amp;obj.Size, &amp;obj.ETag, &amp;obj.ContentType, &amp;obj.LastModified, &amp;obj.StoragePath)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;obj, err</span>
}

func (m *MetadataStore) DeleteObject(bucket, key string) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec("DELETE FROM objects WHERE bucket = ? AND key = ?", bucket, key)
                return err
        }</span>)
}

func (m *MetadataStore) ListObjects(bucket, prefix, marker, delimiter string, maxKeys int) (*ListObjectsResult, error) <span class="cov8" title="1">{
        result := &amp;ListObjectsResult{
                Name:      bucket,
                Prefix:    prefix,
                Delimiter: delimiter,
                MaxKeys:   maxKeys,
        }

        query := "SELECT bucket, key, size, etag, content_type, last_modified, storage_path FROM objects WHERE bucket = ?"
        args := []interface{}{bucket}

        if prefix != "" </span><span class="cov8" title="1">{
                query += " AND key LIKE ?"
                args = append(args, prefix+"%")
        }</span>
        <span class="cov8" title="1">if marker != "" </span><span class="cov8" title="1">{
                query += " AND key &gt; ?"
                args = append(args, marker)
        }</span>

        <span class="cov8" title="1">query += " ORDER BY key LIMIT ?"
        args = append(args, maxKeys+1)

        rows, err := m.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        prefixSet := make(map[string]bool)
        for rows.Next() </span><span class="cov8" title="1">{
                var obj Object
                if err := rows.Scan(&amp;obj.Bucket, &amp;obj.Key, &amp;obj.Size, &amp;obj.ETag, &amp;obj.ContentType, &amp;obj.LastModified, &amp;obj.StoragePath); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 处理分隔符
                <span class="cov8" title="1">if delimiter != "" &amp;&amp; prefix != "" </span><span class="cov0" title="0">{
                        rest := strings.TrimPrefix(obj.Key, prefix)
                        if idx := strings.Index(rest, delimiter); idx &gt;= 0 </span><span class="cov0" title="0">{
                                commonPrefix := prefix + rest[:idx+1]
                                if !prefixSet[commonPrefix] </span><span class="cov0" title="0">{
                                        prefixSet[commonPrefix] = true
                                        result.CommonPrefixes = append(result.CommonPrefixes, commonPrefix)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                }

                <span class="cov8" title="1">if len(result.Contents) &lt; maxKeys </span><span class="cov8" title="1">{
                        result.Contents = append(result.Contents, obj)
                }</span> else<span class="cov8" title="1"> {
                        result.IsTruncated = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if len(result.Contents) &gt; 0 </span><span class="cov8" title="1">{
                result.NextMarker = result.Contents[len(result.Contents)-1].Key
        }</span>
        <span class="cov8" title="1">result.KeyCount = len(result.Contents)

        return result, nil</span>
}

// === Multipart Upload 操作 ===

func (m *MetadataStore) CreateMultipartUpload(upload *MultipartUpload) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(`
                        INSERT INTO multipart_uploads (upload_id, bucket, key, initiated, content_type)
                        VALUES (?, ?, ?, ?, ?)`,
                        upload.UploadID, upload.Bucket, upload.Key, upload.Initiated, upload.ContentType,
                )
                return err
        }</span>)
}

func (m *MetadataStore) GetMultipartUpload(uploadID string) (*MultipartUpload, error) <span class="cov8" title="1">{
        var upload MultipartUpload
        err := m.db.QueryRow(`
                SELECT upload_id, bucket, key, initiated, content_type
                FROM multipart_uploads WHERE upload_id = ?`, uploadID,
        ).Scan(&amp;upload.UploadID, &amp;upload.Bucket, &amp;upload.Key, &amp;upload.Initiated, &amp;upload.ContentType)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;upload, err</span>
}

func (m *MetadataStore) DeleteMultipartUpload(uploadID string) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec("DELETE FROM multipart_uploads WHERE upload_id = ?", uploadID)
                return err
        }</span>)
}

func (m *MetadataStore) PutPart(part *Part) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(`
                        INSERT OR REPLACE INTO parts (upload_id, part_number, size, etag, modified_at)
                        VALUES (?, ?, ?, ?, ?)`,
                        part.UploadID, part.PartNumber, part.Size, part.ETag, part.ModifiedAt,
                )
                return err
        }</span>)
}

func (m *MetadataStore) ListParts(uploadID string) ([]Part, error) <span class="cov8" title="1">{
        rows, err := m.db.Query(`
                SELECT upload_id, part_number, size, etag, modified_at
                FROM parts WHERE upload_id = ? ORDER BY part_number`, uploadID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var parts []Part
        for rows.Next() </span><span class="cov8" title="1">{
                var p Part
                if err := rows.Scan(&amp;p.UploadID, &amp;p.PartNumber, &amp;p.Size, &amp;p.ETag, &amp;p.ModifiedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">parts = append(parts, p)</span>
        }
        <span class="cov8" title="1">return parts, nil</span>
}

func (m *MetadataStore) DeleteParts(uploadID string) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec("DELETE FROM parts WHERE upload_id = ?", uploadID)
                return err
        }</span>)
}

// escapeLikePattern 转义LIKE模式中的特殊字符
func escapeLikePattern(pattern string) string <span class="cov8" title="1">{
        // 转义 %、_ 和 \ 这些LIKE中的特殊字符
        result := strings.ReplaceAll(pattern, "\\", "\\\\")
        result = strings.ReplaceAll(result, "%", "\\%")
        result = strings.ReplaceAll(result, "_", "\\_")
        return result
}</span>

// SearchObjects 模糊搜索对象（按文件名关键字）
func (m *MetadataStore) SearchObjects(bucket, keyword string, maxResults int) ([]Object, error) <span class="cov8" title="1">{
        if maxResults &lt;= 0 </span><span class="cov0" title="0">{
                maxResults = 100
        }</span>
        <span class="cov8" title="1">if maxResults &gt; 1000 </span><span class="cov0" title="0">{
                maxResults = 1000 // 限制最大结果数
        }</span>

        // 转义关键字中的特殊字符，防止SQL注入
        <span class="cov8" title="1">escapedKeyword := escapeLikePattern(keyword)

        query := "SELECT bucket, key, size, etag, content_type, last_modified, storage_path FROM objects WHERE bucket = ? AND key LIKE ? ESCAPE '\\' ORDER BY key LIMIT ?"
        // 使用 %keyword% 实现模糊匹配
        args := []interface{}{bucket, "%" + escapedKeyword + "%", maxResults}

        rows, err := m.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var objects []Object
        for rows.Next() </span><span class="cov8" title="1">{
                var obj Object
                if err := rows.Scan(&amp;obj.Bucket, &amp;obj.Key, &amp;obj.Size, &amp;obj.ETag, &amp;obj.ContentType, &amp;obj.LastModified, &amp;obj.StoragePath); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">objects = append(objects, obj)</span>
        }
        <span class="cov8" title="1">return objects, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package storage

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
)

// MigrateConfig 迁移配置
type MigrateConfig struct {
        SourceEndpoint  string `json:"sourceEndpoint"`
        SourceAccessKey string `json:"sourceAccessKey"`
        SourceSecretKey string `json:"sourceSecretKey"`
        SourceBucket    string `json:"sourceBucket"`
        SourcePrefix    string `json:"sourcePrefix"`    // 可选：只迁移指定前缀的对象
        SourceRegion    string `json:"sourceRegion"`    // 可选：源服务区域
        TargetBucket    string `json:"targetBucket"`
        TargetPrefix    string `json:"targetPrefix"`    // 可选：目标前缀
        OverwriteExist  bool   `json:"overwriteExist"`  // 是否覆盖已存在的文件
}

// MigrateProgress 迁移进度
type MigrateProgress struct {
        JobID         string     `json:"jobId"`
        Status        string     `json:"status"` // pending, running, completed, failed, cancelled
        TotalObjects  int        `json:"totalObjects"`
        Completed     int        `json:"completed"`
        Failed        int        `json:"failed"`
        Skipped       int        `json:"skipped"`     // 跳过的已存在文件
        TotalSize     int64      `json:"totalSize"`   // 总字节数
        TransferSize  int64      `json:"transferSize"` // 已传输字节数
        CurrentFile   string     `json:"currentFile,omitempty"`
        StartTime     time.Time  `json:"startTime"`
        EndTime       *time.Time `json:"endTime,omitempty"`
        Error         string     `json:"error,omitempty"`
        FailedObjects []string   `json:"failedObjects,omitempty"` // 失败的对象列表
        Config        MigrateConfig `json:"config"`
}

// MigrateManager 迁移任务管理器
type MigrateManager struct {
        mu       sync.RWMutex
        jobs     map[string]*MigrateProgress
        metadata *MetadataStore
        fileStore *FileStore
}

// 全局迁移管理器
var migrateManager *MigrateManager
var migrateOnce sync.Once

// GetMigrateManager 获取迁移管理器单例
func GetMigrateManager(metadata *MetadataStore, fileStore *FileStore) *MigrateManager <span class="cov8" title="1">{
        migrateOnce.Do(func() </span><span class="cov8" title="1">{
                migrateManager = &amp;MigrateManager{
                        jobs:     make(map[string]*MigrateProgress),
                        metadata: metadata,
                        fileStore: fileStore,
                }
        }</span>)
        <span class="cov8" title="1">return migrateManager</span>
}

// ResetMigrateManagerForTest 重置迁移管理器（仅用于测试）
// 注意：此函数不是线程安全的，仅应在测试初始化时调用
func ResetMigrateManagerForTest() <span class="cov0" title="0">{
        migrateOnce = sync.Once{}
        migrateManager = nil
}</span>

// generateJobID 生成任务ID
func generateJobID() string <span class="cov8" title="1">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

// StartMigration 启动迁移任务
func (m *MigrateManager) StartMigration(cfg MigrateConfig) (string, error) <span class="cov8" title="1">{
        // 验证配置
        if cfg.SourceEndpoint == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("sourceEndpoint is required")
        }</span>
        <span class="cov8" title="1">if cfg.SourceAccessKey == "" || cfg.SourceSecretKey == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("source credentials are required")
        }</span>
        <span class="cov8" title="1">if cfg.SourceBucket == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("sourceBucket is required")
        }</span>
        <span class="cov8" title="1">if cfg.TargetBucket == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("targetBucket is required")
        }</span>

        // 检查目标桶是否存在
        <span class="cov8" title="1">bucket, err := m.metadata.GetBucket(cfg.TargetBucket)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to check target bucket: %w", err)
        }</span>
        <span class="cov8" title="1">if bucket == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("target bucket not found: %s", cfg.TargetBucket)
        }</span>

        // 设置默认区域
        <span class="cov8" title="1">if cfg.SourceRegion == "" </span><span class="cov8" title="1">{
                cfg.SourceRegion = "us-east-1"
        }</span>

        // 生成任务ID
        <span class="cov8" title="1">jobID := generateJobID()

        // 创建进度记录
        progress := &amp;MigrateProgress{
                JobID:     jobID,
                Status:    "pending",
                StartTime: time.Now(),
                Config:    cfg,
        }

        m.mu.Lock()
        m.jobs[jobID] = progress
        m.mu.Unlock()

        // 启动后台任务
        go m.runMigration(jobID, cfg)

        return jobID, nil</span>
}

// GetProgress 获取迁移进度
func (m *MigrateManager) GetProgress(jobID string) *MigrateProgress <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.jobs[jobID]
}</span>

// GetAllJobs 获取所有任务
func (m *MigrateManager) GetAllJobs() []*MigrateProgress <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        result := make([]*MigrateProgress, 0, len(m.jobs))
        for _, job := range m.jobs </span><span class="cov8" title="1">{
                result = append(result, job)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// CancelMigration 取消迁移任务
func (m *MigrateManager) CancelMigration(jobID string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        job, exists := m.jobs[jobID]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("job not found: %s", jobID)
        }</span>

        <span class="cov8" title="1">if job.Status == "completed" || job.Status == "failed" || job.Status == "cancelled" </span><span class="cov8" title="1">{
                return fmt.Errorf("job already finished")
        }</span>

        <span class="cov8" title="1">job.Status = "cancelled"
        now := time.Now()
        job.EndTime = &amp;now
        return nil</span>
}

// DeleteJob 删除任务记录
func (m *MigrateManager) DeleteJob(jobID string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        job, exists := m.jobs[jobID]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("job not found: %s", jobID)
        }</span>

        <span class="cov8" title="1">if job.Status == "running" || job.Status == "pending" </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot delete running job")
        }</span>

        <span class="cov8" title="1">delete(m.jobs, jobID)
        return nil</span>
}

// runMigration 执行迁移
func (m *MigrateManager) runMigration(jobID string, cfg MigrateConfig) <span class="cov8" title="1">{
        m.mu.Lock()
        progress := m.jobs[jobID]
        progress.Status = "running"
        m.mu.Unlock()

        defer func() </span><span class="cov8" title="1">{
                m.mu.Lock()
                if progress.Status == "running" </span><span class="cov0" title="0">{
                        if progress.Failed &gt; 0 </span><span class="cov0" title="0">{
                                progress.Status = "completed"
                                progress.Error = fmt.Sprintf("%d objects failed", progress.Failed)
                        }</span> else<span class="cov0" title="0"> {
                                progress.Status = "completed"
                        }</span>
                }
                <span class="cov8" title="1">now := time.Now()
                progress.EndTime = &amp;now
                m.mu.Unlock()</span>
        }()

        // 创建 S3 客户端
        <span class="cov8" title="1">ctx := context.Background()
        s3Client, err := m.createS3Client(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                m.setError(progress, fmt.Sprintf("failed to create S3 client: %v", err))
                return
        }</span>

        // 列出源桶对象
        <span class="cov8" title="1">objects, err := m.listSourceObjects(ctx, s3Client, cfg)
        if err != nil </span><span class="cov8" title="1">{
                m.setError(progress, fmt.Sprintf("failed to list source objects: %v", err))
                return
        }</span>

        <span class="cov0" title="0">m.mu.Lock()
        progress.TotalObjects = len(objects)
        m.mu.Unlock()

        if len(objects) == 0 </span><span class="cov0" title="0">{
                slog.Info("迁移任务完成，无对象需要迁移", "jobId", jobID)
                return
        }</span>

        // 逐个迁移对象
        <span class="cov0" title="0">for _, obj := range objects </span><span class="cov0" title="0">{
                // 检查是否被取消
                m.mu.RLock()
                if progress.Status == "cancelled" </span><span class="cov0" title="0">{
                        m.mu.RUnlock()
                        return
                }</span>
                <span class="cov0" title="0">m.mu.RUnlock()

                // 更新当前文件
                m.mu.Lock()
                progress.CurrentFile = obj.Key
                m.mu.Unlock()

                // 计算目标 key
                targetKey := obj.Key
                if cfg.SourcePrefix != "" &amp;&amp; cfg.TargetPrefix != "" </span><span class="cov0" title="0">{
                        // 替换前缀
                        targetKey = cfg.TargetPrefix + obj.Key[len(cfg.SourcePrefix):]
                }</span> else<span class="cov0" title="0"> if cfg.TargetPrefix != "" </span><span class="cov0" title="0">{
                        targetKey = cfg.TargetPrefix + obj.Key
                }</span>

                // 检查目标是否已存在
                <span class="cov0" title="0">if !cfg.OverwriteExist </span><span class="cov0" title="0">{
                        existingObj, _ := m.metadata.GetObject(cfg.TargetBucket, targetKey)
                        if existingObj != nil </span><span class="cov0" title="0">{
                                m.mu.Lock()
                                progress.Skipped++
                                progress.Completed++
                                m.mu.Unlock()
                                continue</span>
                        }
                }

                // 下载并上传对象
                <span class="cov0" title="0">err := m.transferObject(ctx, s3Client, cfg, obj.Key, targetKey, obj.Size)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("迁移对象失败",
                                "jobId", jobID,
                                "key", obj.Key,
                                "error", err)
                        m.mu.Lock()
                        progress.Failed++
                        progress.FailedObjects = append(progress.FailedObjects, obj.Key)
                        m.mu.Unlock()
                }</span> else<span class="cov0" title="0"> {
                        m.mu.Lock()
                        progress.Completed++
                        progress.TransferSize += obj.Size
                        m.mu.Unlock()
                }</span>
        }

        <span class="cov0" title="0">slog.Info("迁移任务完成",
                "jobId", jobID,
                "total", progress.TotalObjects,
                "completed", progress.Completed,
                "failed", progress.Failed,
                "skipped", progress.Skipped)</span>
}

// sourceObject 源对象信息
type sourceObject struct {
        Key  string
        Size int64
        ETag string
}

// createS3Client 创建源 S3 客户端
func (m *MigrateManager) createS3Client(ctx context.Context, cfg MigrateConfig) (*s3.Client, error) <span class="cov8" title="1">{
        // 创建自定义凭证提供程序
        creds := credentials.NewStaticCredentialsProvider(
                cfg.SourceAccessKey,
                cfg.SourceSecretKey,
                "",
        )

        // 创建自定义端点解析器
        customResolver := aws.EndpointResolverWithOptionsFunc(
                func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov8" title="1">{
                        return aws.Endpoint{
                                URL:               cfg.SourceEndpoint,
                                HostnameImmutable: true,
                        }, nil
                }</span>,
        )

        // 加载配置
        <span class="cov8" title="1">awsCfg, err := config.LoadDefaultConfig(ctx,
                config.WithRegion(cfg.SourceRegion),
                config.WithCredentialsProvider(creds),
                config.WithEndpointResolverWithOptions(customResolver),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 创建 S3 客户端，使用 path-style（兼容大多数 S3 兼容服务）
        <span class="cov8" title="1">client := s3.NewFromConfig(awsCfg, func(o *s3.Options) </span><span class="cov8" title="1">{
                o.UsePathStyle = true
        }</span>)

        <span class="cov8" title="1">return client, nil</span>
}

// listSourceObjects 列出源桶中的所有对象
func (m *MigrateManager) listSourceObjects(ctx context.Context, client *s3.Client, cfg MigrateConfig) ([]sourceObject, error) <span class="cov8" title="1">{
        var objects []sourceObject
        var continuationToken *string

        for </span><span class="cov8" title="1">{
                input := &amp;s3.ListObjectsV2Input{
                        Bucket: aws.String(cfg.SourceBucket),
                }
                if cfg.SourcePrefix != "" </span><span class="cov8" title="1">{
                        input.Prefix = aws.String(cfg.SourcePrefix)
                }</span>
                <span class="cov8" title="1">if continuationToken != nil </span><span class="cov0" title="0">{
                        input.ContinuationToken = continuationToken
                }</span>

                <span class="cov8" title="1">resp, err := client.ListObjectsV2(ctx, input)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, obj := range resp.Contents </span><span class="cov0" title="0">{
                        objects = append(objects, sourceObject{
                                Key:  aws.ToString(obj.Key),
                                Size: aws.ToInt64(obj.Size),
                                ETag: aws.ToString(obj.ETag),
                        })
                }</span>

                <span class="cov0" title="0">if !aws.ToBool(resp.IsTruncated) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">continuationToken = resp.NextContinuationToken</span>
        }

        <span class="cov0" title="0">return objects, nil</span>
}

// transferObject 传输单个对象
func (m *MigrateManager) transferObject(ctx context.Context, client *s3.Client, cfg MigrateConfig, sourceKey, targetKey string, size int64) error <span class="cov0" title="0">{
        // 从源下载
        getResp, err := client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(cfg.SourceBucket),
                Key:    aws.String(sourceKey),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get object: %w", err)
        }</span>
        <span class="cov0" title="0">defer getResp.Body.Close()

        // 获取 Content-Type
        contentType := "application/octet-stream"
        if getResp.ContentType != nil </span><span class="cov0" title="0">{
                contentType = *getResp.ContentType
        }</span>

        // 存储到本地
        <span class="cov0" title="0">storagePath, etag, err := m.fileStore.PutObject(cfg.TargetBucket, targetKey, getResp.Body, size)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store object: %w", err)
        }</span>

        // 保存元数据
        <span class="cov0" title="0">obj := &amp;Object{
                Bucket:       cfg.TargetBucket,
                Key:          targetKey,
                Size:         size,
                ETag:         etag,
                ContentType:  contentType,
                StoragePath:  storagePath,
                LastModified: time.Now(),
        }
        err = m.metadata.PutObject(obj)
        if err != nil </span><span class="cov0" title="0">{
                // 清理已存储的文件
                m.fileStore.DeleteObject(storagePath)
                return fmt.Errorf("failed to save metadata: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setError 设置错误状态
func (m *MigrateManager) setError(progress *MigrateProgress, errMsg string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        progress.Status = "failed"
        progress.Error = errMsg
        now := time.Now()
        progress.EndTime = &amp;now
}</span>

// ValidateMigrateConfig 验证迁移配置（连接测试）
func (m *MigrateManager) ValidateMigrateConfig(cfg MigrateConfig) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        // 设置默认区域
        if cfg.SourceRegion == "" </span><span class="cov0" title="0">{
                cfg.SourceRegion = "us-east-1"
        }</span>

        // 创建客户端
        <span class="cov0" title="0">client, err := m.createS3Client(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create client: %w", err)
        }</span>

        // 尝试列出对象（只取1个）
        <span class="cov0" title="0">_, err = client.ListObjectsV2(ctx, &amp;s3.ListObjectsV2Input{
                Bucket:  aws.String(cfg.SourceBucket),
                MaxKeys: aws.Int32(1),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to access bucket: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetJobStats 获取任务统计
func (m *MigrateManager) GetJobStats() map[string]int <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := map[string]int{
                "total":     len(m.jobs),
                "pending":   0,
                "running":   0,
                "completed": 0,
                "failed":    0,
                "cancelled": 0,
        }

        for _, job := range m.jobs </span><span class="cov8" title="1">{
                stats[job.Status]++
        }</span>

        <span class="cov8" title="1">return stats</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package storage

import (
        "database/sql"
        "errors"
        "time"
        "unicode"

        "golang.org/x/crypto/bcrypt"
)

// 密码验证错误
var (
        ErrPasswordTooShort = errors.New("密码长度至少为 8 个字符")
        ErrPasswordNoUpper  = errors.New("密码必须包含至少一个大写字母")
        ErrPasswordNoLower  = errors.New("密码必须包含至少一个小写字母")
        ErrPasswordNoDigit  = errors.New("密码必须包含至少一个数字")
)

// SystemSetting 系统配置项
type SystemSetting struct {
        Key       string    `json:"key"`
        Value     string    `json:"value"`
        UpdatedAt time.Time `json:"updated_at"`
}

// 配置键常量
const (
        // 系统状态
        SettingSystemInstalled   = "system.installed"
        SettingSystemInstalledAt = "system.installed_at"
        SettingSystemVersion     = "system.version"

        // 服务器配置
        SettingServerHost   = "server.host"
        SettingServerPort   = "server.port"
        SettingServerRegion = "server.region"

        // 存储配置
        SettingStorageDataPath      = "storage.data_path"
        SettingStorageMaxObjectSize = "storage.max_object_size"
        SettingStorageMaxUploadSize = "storage.max_upload_size"

        // 安全配置
        SettingSecurityCORSOrigin     = "security.cors_origin"      // CORS 允许的来源，默认 "*"
        SettingSecurityPresignScheme  = "security.presign_scheme"   // 预签名URL协议，"http" 或 "https"

        // 认证配置
        SettingAuthAdminUsername     = "auth.admin_username"
        SettingAuthAdminPasswordHash = "auth.admin_password_hash"

        // 旧版兼容配置（API Key）
        SettingAuthAccessKeyID     = "auth.access_key_id"
        SettingAuthSecretAccessKey = "auth.secret_access_key"
)

// initSettingsTable 初始化系统配置表
func (m *MetadataStore) initSettingsTable() error <span class="cov0" title="0">{
        schema := `CREATE TABLE IF NOT EXISTS system_settings (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at DATETIME NOT NULL
        )`
        _, err := m.db.Exec(schema)
        return err
}</span>

// GetSetting 获取配置项
func (m *MetadataStore) GetSetting(key string) (string, error) <span class="cov8" title="1">{
        var value string
        err := m.db.QueryRow("SELECT value FROM system_settings WHERE key = ?", key).Scan(&amp;value)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return value, err</span>
}

// SetSetting 设置配置项
func (m *MetadataStore) SetSetting(key, value string) error <span class="cov8" title="1">{
        return m.withWriteLock(func() error </span><span class="cov8" title="1">{
                _, err := m.db.Exec(`
                        INSERT OR REPLACE INTO system_settings (key, value, updated_at)
                        VALUES (?, ?, ?)`,
                        key, value, time.Now().UTC(),
                )
                return err
        }</span>)
}

// GetSettings 批量获取配置项
func (m *MetadataStore) GetSettings(keys []string) (map[string]string, error) <span class="cov8" title="1">{
        result := make(map[string]string)
        for _, key := range keys </span><span class="cov8" title="1">{
                value, err := m.GetSetting(key)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result[key] = value</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetAllSettings 获取所有配置项
func (m *MetadataStore) GetAllSettings() ([]SystemSetting, error) <span class="cov8" title="1">{
        rows, err := m.db.Query("SELECT key, value, updated_at FROM system_settings ORDER BY key")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var settings []SystemSetting
        for rows.Next() </span><span class="cov8" title="1">{
                var s SystemSetting
                if err := rows.Scan(&amp;s.Key, &amp;s.Value, &amp;s.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">settings = append(settings, s)</span>
        }
        <span class="cov8" title="1">return settings, nil</span>
}

// IsInstalled 检查系统是否已安装
func (m *MetadataStore) IsInstalled() bool <span class="cov8" title="1">{
        value, err := m.GetSetting(SettingSystemInstalled)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return value == "true"</span>
}

// SetInstalled 设置系统为已安装状态
func (m *MetadataStore) SetInstalled() error <span class="cov8" title="1">{
        if err := m.SetSetting(SettingSystemInstalled, "true"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return m.SetSetting(SettingSystemInstalledAt, time.Now().UTC().Format(time.RFC3339))</span>
}

// ValidatePassword 验证密码复杂度
// 要求：至少 8 个字符，包含大写字母、小写字母和数字
func ValidatePassword(password string) error <span class="cov8" title="1">{
        if len(password) &lt; 8 </span><span class="cov8" title="1">{
                return ErrPasswordTooShort
        }</span>

        <span class="cov8" title="1">var hasUpper, hasLower, hasDigit bool
        for _, c := range password </span><span class="cov8" title="1">{
                switch </span>{
                case unicode.IsUpper(c):<span class="cov8" title="1">
                        hasUpper = true</span>
                case unicode.IsLower(c):<span class="cov8" title="1">
                        hasLower = true</span>
                case unicode.IsDigit(c):<span class="cov8" title="1">
                        hasDigit = true</span>
                }
        }

        <span class="cov8" title="1">if !hasUpper </span><span class="cov8" title="1">{
                return ErrPasswordNoUpper
        }</span>
        <span class="cov8" title="1">if !hasLower </span><span class="cov8" title="1">{
                return ErrPasswordNoLower
        }</span>
        <span class="cov8" title="1">if !hasDigit </span><span class="cov8" title="1">{
                return ErrPasswordNoDigit
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SetAdminPassword 设置管理员密码（验证复杂度后 bcrypt 哈希）
func (m *MetadataStore) SetAdminPassword(password string) error <span class="cov8" title="1">{
        // 验证密码复杂度
        if err := ValidatePassword(password); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return m.SetSetting(SettingAuthAdminPasswordHash, string(hash))</span>
}

// VerifyAdminPassword 验证管理员密码
func (m *MetadataStore) VerifyAdminPassword(password string) bool <span class="cov8" title="1">{
        hash, err := m.GetSetting(SettingAuthAdminPasswordHash)
        if err != nil || hash == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil</span>
}

// GetAdminUsername 获取管理员用户名
func (m *MetadataStore) GetAdminUsername() string <span class="cov8" title="1">{
        username, err := m.GetSetting(SettingAuthAdminUsername)
        if err != nil || username == "" </span><span class="cov8" title="1">{
                return "admin" // 默认用户名
        }</span>
        <span class="cov8" title="1">return username</span>
}

// InitDefaultSettings 初始化默认配置（安装时调用）
func (m *MetadataStore) InitDefaultSettings(adminUsername, adminPassword string) error <span class="cov8" title="1">{
        // 服务器配置
        defaults := map[string]string{
                SettingServerHost:           "0.0.0.0",
                SettingServerPort:           "8080",
                SettingServerRegion:         "us-east-1",
                SettingStorageDataPath:      "./data/buckets",
                SettingStorageMaxObjectSize: "5368709120", // 5GB
                SettingStorageMaxUploadSize: "1073741824", // 1GB
                SettingAuthAdminUsername:    adminUsername,
                SettingSystemVersion:        "1.1.0",
        }

        for key, value := range defaults </span><span class="cov8" title="1">{
                if err := m.SetSetting(key, value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // 设置密码（bcrypt 哈希）
        <span class="cov8" title="1">if err := m.SetAdminPassword(adminPassword); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 生成默认 API Key
        <span class="cov8" title="1">accessKeyID := generateRandomKey(20)
        secretAccessKey := generateRandomKey(40)
        if err := m.SetSetting(SettingAuthAccessKeyID, accessKeyID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := m.SetSetting(SettingAuthSecretAccessKey, secretAccessKey); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetServerConfig 获取服务器配置
func (m *MetadataStore) GetServerConfig() (host string, port int, region string) <span class="cov8" title="1">{
        host, _ = m.GetSetting(SettingServerHost)
        if host == "" </span><span class="cov8" title="1">{
                host = "0.0.0.0"
        }</span>

        <span class="cov8" title="1">portStr, _ := m.GetSetting(SettingServerPort)
        port = 8080
        if portStr != "" </span><span class="cov8" title="1">{
                var p int
                if _, err := parseIntSafe(portStr, &amp;p); err == nil &amp;&amp; p &gt; 0 </span><span class="cov8" title="1">{
                        port = p
                }</span>
        }

        <span class="cov8" title="1">region, _ = m.GetSetting(SettingServerRegion)
        if region == "" </span><span class="cov8" title="1">{
                region = "us-east-1"
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStorageConfig 获取存储配置
func (m *MetadataStore) GetStorageConfig() (dataPath string, maxObjectSize, maxUploadSize int64) <span class="cov8" title="1">{
        dataPath, _ = m.GetSetting(SettingStorageDataPath)
        if dataPath == "" </span><span class="cov8" title="1">{
                dataPath = "./data/buckets"
        }</span>

        <span class="cov8" title="1">maxObjectSizeStr, _ := m.GetSetting(SettingStorageMaxObjectSize)
        maxObjectSize = 5 * 1024 * 1024 * 1024 // 5GB 默认
        if maxObjectSizeStr != "" </span><span class="cov8" title="1">{
                var size int64
                if _, err := parseInt64Safe(maxObjectSizeStr, &amp;size); err == nil &amp;&amp; size &gt; 0 </span><span class="cov8" title="1">{
                        maxObjectSize = size
                }</span>
        }

        <span class="cov8" title="1">maxUploadSizeStr, _ := m.GetSetting(SettingStorageMaxUploadSize)
        maxUploadSize = 1024 * 1024 * 1024 // 1GB 默认
        if maxUploadSizeStr != "" </span><span class="cov8" title="1">{
                var size int64
                if _, err := parseInt64Safe(maxUploadSizeStr, &amp;size); err == nil &amp;&amp; size &gt; 0 </span><span class="cov8" title="1">{
                        maxUploadSize = size
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// GetAuthConfig 获取认证配置
func (m *MetadataStore) GetAuthConfig() (accessKeyID, secretAccessKey string) <span class="cov8" title="1">{
        accessKeyID, _ = m.GetSetting(SettingAuthAccessKeyID)
        secretAccessKey, _ = m.GetSetting(SettingAuthSecretAccessKey)
        return
}</span>

// 辅助函数：安全解析整数
func parseIntSafe(s string, result *int) (int, error) <span class="cov8" title="1">{
        var n int
        for _, c := range s </span><span class="cov8" title="1">{
                if c &lt; '0' || c &gt; '9' </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">n = n*10 + int(c-'0')</span>
        }
        <span class="cov8" title="1">*result = n
        return n, nil</span>
}

func parseInt64Safe(s string, result *int64) (int64, error) <span class="cov8" title="1">{
        var n int64
        for _, c := range s </span><span class="cov8" title="1">{
                if c &lt; '0' || c &gt; '9' </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
                <span class="cov8" title="1">n = n*10 + int64(c-'0')</span>
        }
        <span class="cov8" title="1">*result = n
        return n, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package storage

import (
        "os"
        "path/filepath"
        "strings"
)

// StorageStats 存储统计信息
type StorageStats struct {
        TotalBuckets int          `json:"total_buckets"` // 桶总数
        TotalObjects int          `json:"total_objects"` // 对象总数
        TotalSize    int64        `json:"total_size"`    // 总大小(字节)
        BucketStats  []BucketStat `json:"bucket_stats"`  // 各桶统计
        TypeStats    []TypeStat   `json:"type_stats"`    // 文件类型统计
}

// BucketStat 单个桶的统计
type BucketStat struct {
        Name        string `json:"name"`
        ObjectCount int    `json:"object_count"`
        TotalSize   int64  `json:"total_size"`
        IsPublic    bool   `json:"is_public"`
}

// TypeStat 文件类型统计
type TypeStat struct {
        ContentType string `json:"content_type"` // MIME 类型
        Extension   string `json:"extension"`    // 文件扩展名
        Count       int    `json:"count"`
        TotalSize   int64  `json:"total_size"`
}

// GetStorageStats 获取存储统计信息
func (m *MetadataStore) GetStorageStats() (*StorageStats, error) <span class="cov8" title="1">{
        stats := &amp;StorageStats{}

        // 1. 获取桶总数
        err := m.db.QueryRow("SELECT COUNT(*) FROM buckets").Scan(&amp;stats.TotalBuckets)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. 获取对象总数和总大小
        <span class="cov8" title="1">err = m.db.QueryRow("SELECT COUNT(*), COALESCE(SUM(size), 0) FROM objects").
                Scan(&amp;stats.TotalObjects, &amp;stats.TotalSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 3. 获取各桶统计
        <span class="cov8" title="1">rows, err := m.db.Query(`
                SELECT b.name, b.is_public,
                           COUNT(o.key) as object_count,
                           COALESCE(SUM(o.size), 0) as total_size
                FROM buckets b
                LEFT JOIN objects o ON b.name = o.bucket
                GROUP BY b.name, b.is_public
                ORDER BY total_size DESC
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var bs BucketStat
                if err := rows.Scan(&amp;bs.Name, &amp;bs.IsPublic, &amp;bs.ObjectCount, &amp;bs.TotalSize); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">stats.BucketStats = append(stats.BucketStats, bs)</span>
        }

        // 4. 获取文件类型统计
        <span class="cov8" title="1">typeRows, err := m.db.Query(`
                SELECT content_type, COUNT(*) as count, SUM(size) as total_size
                FROM objects
                WHERE content_type IS NOT NULL AND content_type != ''
                GROUP BY content_type
                ORDER BY total_size DESC
                LIMIT 20
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer typeRows.Close()

        for typeRows.Next() </span><span class="cov8" title="1">{
                var ts TypeStat
                if err := typeRows.Scan(&amp;ts.ContentType, &amp;ts.Count, &amp;ts.TotalSize); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // 从 content_type 提取扩展名显示
                <span class="cov8" title="1">ts.Extension = getExtensionFromContentType(ts.ContentType)
                stats.TypeStats = append(stats.TypeStats, ts)</span>
        }

        <span class="cov8" title="1">return stats, nil</span>
}

// getExtensionFromContentType 从 MIME 类型获取友好扩展名
func getExtensionFromContentType(contentType string) string <span class="cov8" title="1">{
        // 常见 MIME 类型映射
        mimeToExt := map[string]string{
                "image/png":                "PNG",
                "image/jpeg":               "JPEG",
                "image/gif":                "GIF",
                "image/webp":               "WebP",
                "image/svg+xml":            "SVG",
                "text/plain":               "TXT",
                "text/html":                "HTML",
                "text/css":                 "CSS",
                "text/javascript":          "JS",
                "application/json":         "JSON",
                "application/xml":          "XML",
                "application/pdf":          "PDF",
                "application/zip":          "ZIP",
                "application/gzip":         "GZIP",
                "application/x-tar":        "TAR",
                "video/mp4":                "MP4",
                "video/webm":               "WebM",
                "audio/mpeg":               "MP3",
                "audio/wav":                "WAV",
                "application/octet-stream": "Binary",
        }

        if ext, ok := mimeToExt[contentType]; ok </span><span class="cov8" title="1">{
                return ext
        }</span>

        // 尝试从 MIME 类型提取
        <span class="cov8" title="1">parts := strings.Split(contentType, "/")
        if len(parts) == 2 </span><span class="cov8" title="1">{
                return strings.ToUpper(parts[1])
        }</span>

        <span class="cov8" title="1">return "Other"</span>
}

// GetRecentObjects 获取最近上传的对象
func (m *MetadataStore) GetRecentObjects(limit int) ([]Object, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                limit = 10
        }</span>
        <span class="cov8" title="1">if limit &gt; 50 </span><span class="cov8" title="1">{
                limit = 50
        }</span>

        <span class="cov8" title="1">rows, err := m.db.Query(`
                SELECT bucket, key, size, etag, content_type, last_modified, storage_path
                FROM objects
                ORDER BY last_modified DESC
                LIMIT ?
        `, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var objects []Object
        for rows.Next() </span><span class="cov8" title="1">{
                var obj Object
                if err := rows.Scan(&amp;obj.Bucket, &amp;obj.Key, &amp;obj.Size, &amp;obj.ETag,
                        &amp;obj.ContentType, &amp;obj.LastModified, &amp;obj.StoragePath); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">objects = append(objects, obj)</span>
        }
        <span class="cov8" title="1">return objects, nil</span>
}

// GetDiskUsage 获取磁盘使用统计（实际文件系统）
func (f *FileStore) GetDiskUsage() (totalSize int64, fileCount int, err error) <span class="cov8" title="1">{
        err = filepath.Walk(f.basePath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // 忽略错误继续
                }</span>
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        totalSize += info.Size()
                        fileCount++
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package utils

import (
        "net"
        "net/http"
        "strings"
)

// GetClientIP 获取客户端真实 IP
// 支持各种 CDN/代理的头部：
// - CF-Connecting-IP (Cloudflare)
// - X-Real-IP (Nginx)
// - X-Forwarded-For (标准代理头)
// - True-Client-IP (Akamai, Cloudflare Enterprise)
// - X-Client-IP
// - Fastly-Client-IP (Fastly)
// - X-Cluster-Client-IP (Rackspace)
func GetClientIP(r *http.Request) string <span class="cov8" title="1">{
        // 按优先级检查各种头部
        headers := []string{
                "CF-Connecting-IP",    // Cloudflare
                "True-Client-IP",      // Akamai, Cloudflare Enterprise
                "X-Real-IP",           // Nginx
                "X-Client-IP",         // 通用
                "Fastly-Client-IP",    // Fastly CDN
                "X-Cluster-Client-IP", // Rackspace
        }

        for _, header := range headers </span><span class="cov8" title="1">{
                if ip := r.Header.Get(header); ip != "" </span><span class="cov8" title="1">{
                        // 验证是否为有效 IP
                        if parsedIP := net.ParseIP(strings.TrimSpace(ip)); parsedIP != nil </span><span class="cov8" title="1">{
                                return parsedIP.String()
                        }</span>
                }
        }

        // 检查 X-Forwarded-For（可能包含多个 IP，取第一个）
        <span class="cov8" title="1">if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov8" title="1">{
                ips := strings.Split(xff, ",")
                if len(ips) &gt; 0 </span><span class="cov8" title="1">{
                        ip := strings.TrimSpace(ips[0])
                        if parsedIP := net.ParseIP(ip); parsedIP != nil </span><span class="cov8" title="1">{
                                return parsedIP.String()
                        }</span>
                }
        }

        // 从 RemoteAddr 获取 IP
        <span class="cov8" title="1">ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil </span><span class="cov8" title="1">{
                // RemoteAddr 可能不包含端口
                ip = r.RemoteAddr
        }</span>

        // 处理 IPv6 本地地址
        <span class="cov8" title="1">if ip == "::1" </span><span class="cov8" title="1">{
                return "127.0.0.1"
        }</span>

        <span class="cov8" title="1">return ip</span>
}

// GetUserAgent 获取 User-Agent
func GetUserAgent(r *http.Request) string <span class="cov8" title="1">{
        ua := r.Header.Get("User-Agent")
        // 限制长度，防止存储过长的 UA
        if len(ua) &gt; 500 </span><span class="cov8" title="1">{
                ua = ua[:500]
        }</span>
        <span class="cov8" title="1">return ua</span>
}

// IsPrivateIP 判断是否为内网 IP
func IsPrivateIP(ipStr string) bool <span class="cov8" title="1">{
        ip := net.ParseIP(ipStr)
        if ip == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // 检查是否为私有地址
        <span class="cov8" title="1">privateRanges := []string{
                "10.0.0.0/8",
                "172.16.0.0/12",
                "192.168.0.0/16",
                "127.0.0.0/8",
                "::1/128",
                "fc00::/7",
        }

        for _, cidr := range privateRanges </span><span class="cov8" title="1">{
                _, network, err := net.ParseCIDR(cidr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if network.Contains(ip) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package utils

import (
        "log/slog"
        "os"
)

var Logger *slog.Logger

// InitLogger 初始化日志
func InitLogger(level string) <span class="cov8" title="1">{
        var logLevel slog.Level
        switch level </span>{
        case "debug":<span class="cov8" title="1">
                logLevel = slog.LevelDebug</span>
        case "warn":<span class="cov8" title="1">
                logLevel = slog.LevelWarn</span>
        case "error":<span class="cov8" title="1">
                logLevel = slog.LevelError</span>
        default:<span class="cov8" title="1">
                logLevel = slog.LevelInfo</span>
        }

        <span class="cov8" title="1">opts := &amp;slog.HandlerOptions{Level: logLevel}
        Logger = slog.New(slog.NewTextHandler(os.Stdout, opts))</span>
}

func Info(msg string, args ...any) <span class="cov8" title="1">{
        Logger.Info(msg, args...)
}</span>

func Debug(msg string, args ...any) <span class="cov8" title="1">{
        Logger.Debug(msg, args...)
}</span>

func Warn(msg string, args ...any) <span class="cov8" title="1">{
        Logger.Warn(msg, args...)
}</span>

func Error(msg string, args ...any) <span class="cov8" title="1">{
        Logger.Error(msg, args...)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package utils

import (
        "encoding/json"
        "encoding/xml"
        "net/http"
)

// S3Error S3错误响应
type S3Error struct {
        XMLName   xml.Name `xml:"Error"`
        Code      string   `xml:"Code"`
        Message   string   `xml:"Message"`
        Resource  string   `xml:"Resource"`
        RequestID string   `xml:"RequestId"`
}

// 预定义错误
var (
        ErrNoSuchBucket         = S3Error{Code: "NoSuchBucket", Message: "The specified bucket does not exist"}
        ErrNoSuchKey            = S3Error{Code: "NoSuchKey", Message: "The specified key does not exist"}
        ErrBucketAlreadyExists  = S3Error{Code: "BucketAlreadyExists", Message: "The requested bucket name is not available"}
        ErrBucketNotEmpty       = S3Error{Code: "BucketNotEmpty", Message: "The bucket you tried to delete is not empty"}
        ErrAccessDenied         = S3Error{Code: "AccessDenied", Message: "Access Denied"}
        ErrSignatureDoesNotMatch = S3Error{Code: "SignatureDoesNotMatch", Message: "The request signature we calculated does not match the signature you provided"}
        ErrInvalidAccessKeyId   = S3Error{Code: "InvalidAccessKeyId", Message: "The AWS Access Key Id you provided does not exist"}
        ErrNoSuchUpload         = S3Error{Code: "NoSuchUpload", Message: "The specified upload does not exist"}
        ErrInvalidPart          = S3Error{Code: "InvalidPart", Message: "One or more of the specified parts could not be found"}
        ErrInvalidArgument      = S3Error{Code: "InvalidArgument", Message: "Invalid Argument"}
        ErrInternalError        = S3Error{Code: "InternalError", Message: "We encountered an internal error. Please try again."}
        ErrMethodNotAllowed     = S3Error{Code: "MethodNotAllowed", Message: "The specified method is not allowed against this resource"}
        ErrMalformedJSON        = S3Error{Code: "MalformedJSON", Message: "The JSON provided was not well-formed"}
        ErrEntityTooLarge      = S3Error{Code: "EntityTooLarge", Message: "Your proposed upload exceeds the maximum allowed size"}
        ErrBadDigest           = S3Error{Code: "BadDigest", Message: "The Content-MD5 you specified did not match what we received"}
)

// WriteError 写入错误响应
func WriteError(w http.ResponseWriter, err S3Error, statusCode int, resource string) <span class="cov8" title="1">{
        err.Resource = resource
        err.RequestID = GenerateRequestID()

        w.Header().Set("Content-Type", "application/xml")
        w.WriteHeader(statusCode)
        xml.NewEncoder(w).Encode(err)
}</span>

// WriteXML 写入XML响应
func WriteXML(w http.ResponseWriter, statusCode int, v interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/xml")
        w.WriteHeader(statusCode)
        w.Write([]byte(xml.Header))
        xml.NewEncoder(w).Encode(v)
}</span>

// GenerateRequestID 生成请求ID
func GenerateRequestID() string <span class="cov8" title="1">{
        return GenerateID(16)
}</span>

// ParseJSONBody 解析JSON请求体
func ParseJSONBody(r *http.Request, v interface{}) error <span class="cov8" title="1">{
        defer r.Body.Close()
        return json.NewDecoder(r.Body).Decode(v)
}</span>

// WriteJSONResponse 写入JSON响应
func WriteJSONResponse(w http.ResponseWriter, v interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(v)
}</span>

// WriteErrorResponse 写入JSON错误响应
func WriteErrorResponse(w http.ResponseWriter, code, message string, statusCode int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(map[string]string{
                "error":   code,
                "message": message,
        })
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package utils

import (
        "crypto/rand"
        "encoding/hex"
        "time"
)

// GenerateID 生成随机ID
func GenerateID(length int) string <span class="cov8" title="1">{
        b := make([]byte, length)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                // 如果加密随机数生成失败，使用时间戳作为后备方案
                // 这种情况非常罕见，但不应该返回全零
                timestamp := time.Now().UnixNano()
                for i := 0; i &lt; length &amp;&amp; i &lt; 8; i++ </span><span class="cov0" title="0">{
                        b[i] = byte(timestamp &gt;&gt; (i * 8))
                }</span>
        }
        <span class="cov8" title="1">return hex.EncodeToString(b)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package main

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "sort"
        "strings"
        "time"
)

const (
        accessKey  = "admin"
        secretKey  = "admin"
        region     = "us-east-1"
        baseURL    = "http://localhost:8080"
)

func main() <span class="cov0" title="0">{
        bucket := "my-test-bucket"
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                bucket = os.Args[1]
        }</span>
        <span class="cov0" title="0">count := 120
        if len(os.Args) &gt; 2 </span><span class="cov0" title="0">{
                fmt.Sscanf(os.Args[2], "%d", &amp;count)
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 30 * time.Second}

        fmt.Printf("开始上传 %d 个测试文件到 %s 桶...\n", count, bucket)

        success := 0
        for i := 1; i &lt;= count; i++ </span><span class="cov0" title="0">{
                key := fmt.Sprintf("test_file_%03d.txt", i)
                content := fmt.Sprintf("Test file %d - Created at %s\nLine 1\nLine 2\n", i, time.Now().Format(time.RFC3339))

                // 生成预签名URL
                presignedURL := generatePresignedURL("PUT", bucket, key, 5*time.Minute)

                // 创建请求
                req, err := http.NewRequest("PUT", presignedURL, bytes.NewReader([]byte(content)))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("创建请求失败 %s: %v\n", key, err)
                        continue</span>
                }
                <span class="cov0" title="0">req.Header.Set("Content-Type", "text/plain")

                // 上传文件
                resp, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("上传失败 %s: %v\n", key, err)
                        continue</span>
                }

                <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                        body, _ := io.ReadAll(resp.Body)
                        fmt.Printf("上传失败 %s: %d %s\n", key, resp.StatusCode, string(body))
                        resp.Body.Close()
                        continue</span>
                }
                <span class="cov0" title="0">resp.Body.Close()
                success++

                if i%20 == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("已上传 %d/%d 个文件\n", i, count)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("完成！成功上传 %d/%d 个测试文件到 %s 桶\n", success, count, bucket)</span>
}

// generatePresignedURL 生成预签名URL（AWS Signature V4）
func generatePresignedURL(method, bucket, key string, expires time.Duration) string <span class="cov0" title="0">{
        now := time.Now().UTC()
        dateStr := now.Format("20060102")
        amzDate := now.Format("20060102T150405Z")
        expiresSeconds := int(expires.Seconds())

        // 构建URL
        u, _ := url.Parse(baseURL)
        u.Path = "/" + bucket + "/" + key

        // 查询参数
        q := url.Values{}
        q.Set("X-Amz-Algorithm", "AWS4-HMAC-SHA256")
        q.Set("X-Amz-Credential", accessKey+"/"+dateStr+"/"+region+"/s3/aws4_request")
        q.Set("X-Amz-Date", amzDate)
        q.Set("X-Amz-Expires", fmt.Sprintf("%d", expiresSeconds))
        q.Set("X-Amz-SignedHeaders", "host")

        // 规范查询字符串（按字母排序）
        keys := make([]string, 0, len(q))
        for k := range q </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        var canonicalQuery strings.Builder
        for i, k := range keys </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        canonicalQuery.WriteString("&amp;")
                }</span>
                <span class="cov0" title="0">canonicalQuery.WriteString(url.QueryEscape(k))
                canonicalQuery.WriteString("=")
                canonicalQuery.WriteString(url.QueryEscape(q.Get(k)))</span>
        }

        // 规范请求
        <span class="cov0" title="0">canonicalRequest := strings.Join([]string{
                method,
                u.Path,
                canonicalQuery.String(),
                "host:" + u.Host + "\n",
                "host",
                "UNSIGNED-PAYLOAD",
        }, "\n")

        // 待签名字符串
        scope := dateStr + "/" + region + "/s3/aws4_request"
        stringToSign := strings.Join([]string{
                "AWS4-HMAC-SHA256",
                amzDate,
                scope,
                sha256Hex([]byte(canonicalRequest)),
        }, "\n")

        // 计算签名密钥
        kDate := hmacSHA256([]byte("AWS4"+secretKey), dateStr)
        kRegion := hmacSHA256(kDate, region)
        kService := hmacSHA256(kRegion, "s3")
        kSigning := hmacSHA256(kService, "aws4_request")
        signature := hex.EncodeToString(hmacSHA256(kSigning, stringToSign))

        q.Set("X-Amz-Signature", signature)
        u.RawQuery = q.Encode()

        return u.String()</span>
}

func hmacSHA256(key []byte, data string) []byte <span class="cov0" title="0">{
        h := hmac.New(sha256.New, key)
        h.Write([]byte(data))
        return h.Sum(nil)
}</span>

func sha256Hex(data []byte) string <span class="cov0" title="0">{
        h := sha256.Sum256(data)
        return hex.EncodeToString(h[:])
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
